var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Cinema4D Addon","text":"<p>Cinema4D addon integration for AYON.</p>"},{"location":"index.html#setup","title":"Setup","text":""},{"location":"index.html#install-qt-library-for-cinema4d","title":"Install Qt library for Cinema4D","text":"<p>A Qt library must be installed for Cinema4D to ensure the AYON tools can run, either make sure a <code>PySide6</code> or <code>PySide2</code> library is available on <code>PYTHONPATH</code> matching the Python version of the Cinema4D release.</p> <p>Alternatively, you can use the Tray launcher to trigger the <code>Terminal</code> tool to open a command-line initialized for the Cinema4D application. From there you should be able to run:</p> <pre><code>c4dpy.exe -m pip install --ignore-installed PySide6\n</code></pre>"},{"location":"index.html#known-issues","title":"Known Issues","text":""},{"location":"index.html#high-dpi-scaling","title":"High DPI scaling","text":"<p>The Redshift render view may appear oddly scaled on high DPI monitors due to some Qt scaling environment variables that AYON sets by default. To resolve this, launch Cinema4D with the environment variable: <code>QT_AUTO_SCREEN_SCALE_FACTOR=0</code></p> <p>This can be easily setup in the Application environment settings:</p> <pre><code>{\n \"QT_AUTO_SCREEN_SCALE_FACTOR\": \"0\"\n}\n</code></pre>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_cinema4d<ul> <li>addon</li> <li>api<ul> <li>commands</li> <li>exporters</li> <li>lib</li> <li>lib_renderproducts</li> <li>pipeline</li> <li>plugin</li> <li>workio</li> </ul> </li> <li>hooks<ul> <li>pre_pyside_install</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_camera</li> <li>create_pointcache</li> <li>create_redshift_proxy</li> <li>create_render</li> <li>create_review</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>actions</li> <li>load_alembic</li> <li>load_camera</li> <li>load_redshiftproxy</li> <li>load_vdb_to_redshift</li> <li>load_volume</li> <li>load_xref</li> </ul> </li> <li>publish<ul> <li>collect_current_document</li> <li>collect_current_file</li> <li>collect_instances</li> <li>collect_render</li> <li>collect_workfile</li> <li>extract_alembic</li> <li>extract_redshiftproxy</li> <li>extract_review</li> <li>increment_current_file</li> <li>save_scene</li> <li>validate_frame_range</li> <li>validate_render_relative_paths</li> <li>validate_resolution</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>imageio</li> <li>publish</li> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_cinema4d/index.html","title":"ayon_cinema4d","text":""},{"location":"autoapi/client/ayon_cinema4d/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_cinema4d/version.html","title":"version","text":"<p>Package declaring AYON addon 'cinema4d' version.</p>"},{"location":"autoapi/client/ayon_cinema4d/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_cinema4d/api/index.html#client.ayon_cinema4d.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n\n    doc = active_document()\n    previous_selection = doc.GetSelection()\n    try:\n        yield\n    finally:\n        set_selection(doc, previous_selection)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/commands.html","title":"commands","text":""},{"location":"autoapi/client/ayon_cinema4d/api/exporters.html","title":"exporters","text":""},{"location":"autoapi/client/ayon_cinema4d/api/exporters.html#client.ayon_cinema4d.api.exporters.extract_alembic","title":"<code>extract_alembic(filepath, frame_start=None, frame_end=None, frame_step=1, sub_frames=1, global_matrix=False, selection=True, doc=None, verbose=False, **kwargs)</code>","text":"<p>Extract a single Alembic Cache.</p> Source code in <code>client/ayon_cinema4d/api/exporters.py</code> <pre><code>def extract_alembic(filepath,\n                    frame_start=None,\n                    frame_end=None,\n                    frame_step=1,\n                    sub_frames=1,\n                    global_matrix=False,\n                    selection=True,\n                    doc=None,\n                    verbose=False,\n                    **kwargs):\n    \"\"\"Extract a single Alembic Cache.\"\"\"\n    doc = doc or c4d.documents.GetActiveDocument()\n\n    # Fallback to Cinema4d timeline if no start or end frame provided.\n    if frame_start is None:\n        frame_start = doc.GetMinTime().GetFrame(doc.GetFps())\n    if frame_end is None:\n        frame_end = doc.GetMinTime().GetFrame(doc.GetFps())\n\n    # Set export options\n    options = get_plugin_imexport_options(c4d.FORMAT_ABCEXPORT,\n                                          label=\"Alembic\")\n\n    applied_options = {\n        # Animation\n        \"ABCEXPORT_FRAME_START\": frame_start,\n        \"ABCEXPORT_FRAME_END\": frame_end,\n        \"ABCEXPORT_FRAME_STEP\": frame_step,\n        \"ABCEXPORT_SUBFRAMES\": sub_frames,\n\n        # General\n        # \"ABCEXPORT_SCALE\": 1  # \"UnitScaleData\n        \"ABCEXPORT_SELECTION_ONLY\": selection,\n        \"ABCEXPORT_CAMERAS\": kwargs.get(\"cameras\", True),\n        \"ABCEXPORT_SPLINES\": kwargs.get(\"splines\", False),\n        \"ABCEXPORT_HAIR\": kwargs.get(\"hair\", False),\n        \"ABCEXPORT_XREFS\": kwargs.get(\"xrefs\", True),\n        \"ABCEXPORT_GLOBAL_MATRIX\": global_matrix,\n\n        # Subdivision surface\n        \"ABCEXPORT_HYPERNURBS\": kwargs.get(\n            \"subdivisionSurfaces\", True\n        ),\n        \"ABCEXPORT_SDS_WEIGHTS\": kwargs.get(\n            \"subdivisionSurfaceWeights\", False\n        ),\n        \"ABCEXPORT_PARTICLES\": kwargs.get(\"particles\", False),\n        \"ABCEXPORT_PARTICLE_GEOMETRY\": kwargs.get(\n            \"particleGeometry\", False\n        ),\n\n        # Optional data\n        \"ABCEXPORT_VISIBILITY\": kwargs.get(\"visibility\", True),\n        \"ABCEXPORT_UVS\": kwargs.get(\"uvs\", True),\n        \"ABCEXPORT_VERTEX_MAPS\": kwargs.get(\"vertexMaps\", False),\n\n        # Vertex normals\n        \"ABCEXPORT_NORMALS\": kwargs.get(\"normals\", False),\n        \"ABCEXPORT_POLYGONSELECTIONS\": kwargs.get(\"polygonSelections\", True),\n        \"ABCEXPORT_VERTEX_COLORS\": kwargs.get(\"vertexColors\", False),\n        \"ABCEXPORT_POINTS_ONLY\": kwargs.get(\"pointsOnly\", False),\n        \"ABCEXPORT_DISPLAY_COLORS\": kwargs.get(\"displayColors\", False),\n        \"ABCEXPORT_MERGE_CACHE\": kwargs.get(\"mergeCache\", False)\n\n        # \"ABCEXPORT_GROUP\": None,  # ???\n        # # Don't export child objects with only selected?\n        # \"ABCEXPORT_PARENTS_ONLY_MODE\": False,\n        # \"ABCEXPORT_STR_ANIMATION\": None,  # ???\n        # \"ABCEXPORT_STR_GENERAL\": None,  # ???\n        # \"ABCEXPORT_STR_OPTIONS\": None,  # ???\n    }\n    if verbose:\n        log.debug(\n            \"Preparing Alembic export with options: %s\",\n            json.dumps(applied_options, indent=4),\n        )\n\n    for key, value in applied_options.items():\n        key_id = getattr(c4d, key)\n        # There appears to be a bug where if the value is just set directly\n        # that it fails to apply them for the export, e.g. still exporting the\n        # whole scene even though `c4d.ABCEXPORT_SELECTION_ONLY` is True.\n        # See: https://developers.maxon.net/forum/topic/12767/alembic-export-options-not-working/6  # noqa: E501\n        options[key_id] = not value\n        options[key_id] = value\n\n    # Ensure output directory exists\n    parent_dir = os.path.dirname(filepath)\n    os.makedirs(parent_dir, exist_ok=True)\n\n    if c4d.documents.SaveDocument(\n        doc,\n        filepath,\n        c4d.SAVEDOCUMENTFLAGS_DONTADDTORECENTLIST,\n        c4d.FORMAT_ABCEXPORT,\n    ):\n        if verbose:\n            log.debug(\"Extracted Alembic to: %s\", filepath)\n    else:\n        log.error(\"Extraction of Alembic failed: %s\", filepath)\n\n    return filepath\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/exporters.html#client.ayon_cinema4d.api.exporters.extract_fbx","title":"<code>extract_fbx(filepath, verbose=False, **kwargs)</code>","text":"<p>Extract a single fbx file.</p> Source code in <code>client/ayon_cinema4d/api/exporters.py</code> <pre><code>def extract_fbx(filepath, verbose=False, **kwargs):\n    \"\"\"Extract a single fbx file.\"\"\"\n\n    doc = c4d.documents.GetActiveDocument()\n    options = get_plugin_imexport_options(FBX_EXPORTER_ID,\n                                                     label=\"FBX\")\n\n    # File format\n    options[c4d.FBXEXPORT_FBX_VERSION] = kwargs.get(\"fbxVersion\", 0)\n    options[c4d.FBXEXPORT_ASCII] = kwargs.get(\"fbxAscii\", False)\n\n    # General\n    options[c4d.FBXEXPORT_SELECTION_ONLY] = kwargs.get(\"selectionOnly\", False)\n    options[c4d.FBXEXPORT_CAMERAS] = kwargs.get(\"cameras\", True)\n    options[c4d.FBXEXPORT_SPLINES] = kwargs.get(\"splines\", True)\n    options[c4d.FBXEXPORT_INSTANCES] = kwargs.get(\"instances\", True)\n    options[c4d.FBXEXPORT_GLOBAL_MATRIX] = kwargs.get(\"globalMatrix\", False)\n    options[c4d.FBXEXPORT_SDS] = kwargs.get(\"subdivisionSurfaces\", True)\n    options[c4d.FBXEXPORT_LIGHTS] = kwargs.get(\"lights\", True)\n\n    # Animation\n    options[c4d.FBXEXPORT_TRACKS] = kwargs.get(\"tracks\", False)\n    options[c4d.FBXEXPORT_BAKE_ALL_FRAMES] = kwargs.get(\n        \"bakeAllFrames\", False\n    )\n    options[c4d.FBXEXPORT_PLA_TO_VERTEXCACHE] = kwargs.get(\n        \"plaToVertexCache\", False\n    )\n\n    # Geometry\n    options[c4d.FBXEXPORT_SAVE_NORMALS] = kwargs.get(\"normals\", False)\n    options[c4d.FBXEXPORT_SAVE_VERTEX_MAPS_AS_COLORS] = kwargs.get(\n        \"vertexMapsAsColors\", False\n    )\n    options[c4d.FBXEXPORT_SAVE_VERTEX_COLORS] = kwargs.get(\n        \"vertexColors\", False\n    )\n    options[c4d.FBXEXPORT_TRIANGULATE] = kwargs.get(\"triangulate\", False)\n    options[c4d.FBXEXPORT_SDS_SUBDIVISION] = kwargs.get(\n        \"bakedSubdivisionSurfaces\", False\n    )\n    options[c4d.FBXEXPORT_LOD_SUFFIX] = kwargs.get(\"lodSuffix\", False)\n\n    # Additional\n    if hasattr(c4d, \"FBXEXPORT_TEXTURES\"):\n        # Cinema4d S22 doesn't have this option anymore\n        options[c4d.FBXEXPORT_TEXTURES] = kwargs.get(\"textures\", False)\n    if hasattr(c4d, \"FBXEXPORT_BAKE_MATERIALS\"):\n        # Cinema4d S22 now has the ability to bake materials\n        options[c4d.FBXEXPORT_BAKE_MATERIALS] = kwargs.get(\n            \"bakeMaterials\", False\n        )\n    options[c4d.FBXEXPORT_EMBED_TEXTURES] = kwargs.get(\n        \"embedTextures\", False\n    )\n    options[c4d.FBXEXPORT_FLIP_Z_AXIS] = kwargs.get(\"flipZAxis\", False)\n    options[c4d.FBXEXPORT_SUBSTANCES] = kwargs.get(\"substances\", False)\n    options[c4d.FBXEXPORT_UP_AXIS] = kwargs.get(\n        \"upAxis\", c4d.FBXEXPORT_UP_AXIS_Y\n    )\n\n    # Ensure output directory exists\n    parent_dir = os.path.dirname(filepath)\n    if not os.path.exists(parent_dir):\n        os.makedirs(parent_dir)\n\n    if verbose:\n        log.debug(\n            \"Preparing FBX export with options: %s\",\n            json.dumps(kwargs, indent=4),\n        )\n\n    if c4d.documents.SaveDocument(\n        doc,\n        filepath,\n        c4d.SAVEDOCUMENTFLAGS_DONTADDTORECENTLIST,\n        FBX_EXPORTER_ID,\n    ):\n        if verbose:\n            log.debug(\"Extracted FBX to: %s\", filepath)\n    else:\n        log.error(\"Extraction of FBX failed: %s\", filepath)\n\n    return filepath\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/exporters.html#client.ayon_cinema4d.api.exporters.extract_redshiftproxy","title":"<code>extract_redshiftproxy(filepath, frame_start=None, frame_end=None, frame_step=1, selection=True, export_lights=True, export_compress=True, export_polygon_connectivity=False, doc=None, verbose=False)</code>","text":"<p>Extract a Redshift Proxy.</p> Source code in <code>client/ayon_cinema4d/api/exporters.py</code> <pre><code>def extract_redshiftproxy(\n        filepath,\n        frame_start=None,\n        frame_end=None,\n        frame_step=1,\n        selection=True,\n        export_lights=True,\n        export_compress=True,\n        export_polygon_connectivity=False,\n        doc=None,\n        verbose=False):\n    \"\"\"Extract a Redshift Proxy.\"\"\"\n\n    # Redshift may not be available so we import here\n    import redshift  # noqa\n\n    doc = doc or c4d.documents.GetActiveDocument()\n\n    # Fallback to Cinema4d timeline if no start or end frame provided.\n    if frame_start is None:\n        frame_start = doc.GetMinTime().GetFrame(doc.GetFps())\n    if frame_end is None:\n        frame_end = doc.GetMinTime().GetFrame(doc.GetFps())\n\n    # Export at default 1cm scale\n    scale = c4d.UnitScaleData()\n    scale.SetUnitScale(1.0, c4d.DOCUMENT_UNIT_CM)\n\n    # Set export options\n    options = get_plugin_imexport_options(redshift.Frsproxyexport,\n                                          label=\"Alembic\")\n\n    applied_options = {\n        \"REDSHIFT_PROXYEXPORT_ANIMATION_FRAME_END\": frame_end,\n        \"REDSHIFT_PROXYEXPORT_ANIMATION_FRAME_START\": frame_start,\n        \"REDSHIFT_PROXYEXPORT_ANIMATION_FRAME_STEP\": frame_step,\n        \"REDSHIFT_PROXYEXPORT_ANIMATION_RANGE\": c4d.REDSHIFT_PROXYEXPORT_ANIMATION_RANGE_MANUAL,\n        \"REDSHIFT_PROXYEXPORT_EXPORT_COMPRESS\": export_compress,\n        \"REDSHIFT_PROXYEXPORT_EXPORT_LIGHTS\": export_lights,\n        \"REDSHIFT_PROXYEXPORT_EXPORT_POLYGON_CONNECTIVITY\": export_polygon_connectivity,\n        \"REDSHIFT_PROXYEXPORT_OBJECTS\": (\n            c4d.REDSHIFT_PROXYEXPORT_OBJECTS_SELECTION if selection\n            else c4d.REDSHIFT_PROXYEXPORT_OBJECTS_ALL\n        ),\n\n        # Proxy Origin:\n        #   - World Origin: REDSHIFT_PROXYEXPORT_ORIGIN_WORLD\n        #   - Object Bounds: REDSHIFT_PROXYEXPORT_ORIGIN_OBJECTS\n        \"REDSHIFT_PROXYEXPORT_ORIGIN\": c4d.REDSHIFT_PROXYEXPORT_ORIGIN_WORLD,\n\n        # Include default beauty AOV\n        # Keep the default beauty config in the proxy. Used primarily when\n        # exporting entire scenes for rendering with the redshiftCmdLine tool\n        \"REDSHIFT_PROXYEXPORT_AOV_DEFAULT_BEAUTY\": False,\n\n        \"REDSHIFT_PROXYEXPORT_AUTOPROXY_CREATE\": False,\n        # \"REDSHIFT_PROXYEXPORT_AUTOPROXY_PREFIX\": \"RS Proxy\",\n\n        # Do not remove the exported objects\n        \"REDSHIFT_PROXYEXPORT_REMOVE_OBJECTS\": False,\n\n        \"REDSHIFT_PROXYEXPORT_SCALE\": scale,\n\n        # TODO: Set more parameters\n        # \"REDSHIFT_PROXYEXPORT_GROUP\": ...,\n        # \"REDSHIFT_PROXYEXPORT_GROUP_ANIMATION\": ...,\n        # \"REDSHIFT_PROXYEXPORT_GROUP_AOV\": ...,\n        # \"REDSHIFT_PROXYEXPORT_GROUP_AUTOPROXY\": ...,\n        # \"REDSHIFT_PROXYEXPORT_GROUP_OPTIONS\": ...,\n    }\n    if verbose:\n        log.debug(\n            \"Preparing Redshift Proxy export with options: %s\",\n            json.dumps(applied_options, indent=4, default=str),\n        )\n\n    for key, value in applied_options.items():\n        key_id = getattr(c4d, key)\n        # There appears to be a bug where if the value is just set directly\n        # that it fails to apply them for the export, e.g. still exporting the\n        # whole scene even though `c4d.ABCEXPORT_SELECTION_ONLY` is True.\n        # See: https://developers.maxon.net/forum/topic/12767/alembic-export-options-not-working/6  # noqa: E501\n        if isinstance(value, (bool, int)):\n            options[key_id] = not value\n        options[key_id] = value\n\n    # Ensure output directory exists\n    parent_dir = os.path.dirname(filepath)\n    os.makedirs(parent_dir, exist_ok=True)\n\n    if c4d.documents.SaveDocument(\n        doc,\n        filepath,\n        c4d.SAVEDOCUMENTFLAGS_DONTADDTORECENTLIST,\n        redshift.Frsproxyexport,\n    ):\n        if verbose:\n            log.debug(\"Extracted Redshift Proxy to: %s\", filepath)\n    else:\n        log.error(\"Extraction of Redshift Proxy failed: %s\", filepath)\n\n    return filepath\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/exporters.html#client.ayon_cinema4d.api.exporters.render_playblast","title":"<code>render_playblast(filepath, frame_start=None, frame_end=None, fps=None, width=1920, height=1080, doc=None)</code>","text":"<p>Create a playblast of the given or active document.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath to render the movie to.</p> required <code>frame_start</code> <code>Optional[int]</code> <p>Frame start. Defaults to document start time if not provided.</p> <code>None</code> <code>frame_end</code> <code>Optional[int]</code> <p>Frame end. Defaults to document end time if not provided.</p> <code>None</code> <code>fps</code> <code>int</code> <p>Frames per seconds.</p> <code>None</code> <code>width</code> <code>int</code> <p>Resolution width for the render.</p> <code>1920</code> <code>height</code> <code>int</code> <p>Resolution height for the render.</p> <code>1080</code> <code>doc</code> <code>Optional[BaseDocument]</code> <p>Document to operate in. Defaults to active document if not set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The filepath of the rendered movie.</p> Source code in <code>client/ayon_cinema4d/api/exporters.py</code> <pre><code>def render_playblast(filepath,\n                     frame_start=None,\n                     frame_end=None,\n                     fps=None,\n                     width=1920,\n                     height=1080,\n                     doc=None):\n    \"\"\"Create a playblast of the given or active document.\n\n    Args:\n        filepath(str): The filepath to render the movie to.\n        frame_start (Optional[int]): Frame start.\n            Defaults to document start time if not provided.\n        frame_end (Optional[int]): Frame end.\n            Defaults to document end time if not provided.\n        fps (int): Frames per seconds.\n        width (int): Resolution width for the render.\n        height (int): Resolution height for the render.\n        doc (Optional[c4d.documents.BaseDocument]): Document to operate in.\n            Defaults to active document if not set.\n\n    Returns:\n        str: The filepath of the rendered movie.\n    \"\"\"\n\n    # Retrieves the current active render settings\n    doc = doc or c4d.documents.GetActiveDocument()\n    doc_fps = doc.GetFps()\n    if fps is None:\n        fps = doc_fps\n    if frame_start is None:\n        frame_start = doc.GetMinTime().GetFrame(doc_fps)\n    if frame_end is None:\n        frame_end = doc.GetMaxTime().GetFrame(doc_fps)\n\n    renderdata = doc.GetActiveRenderData().GetDataInstance()\n    previous_render_engine = renderdata[c4d.RDATA_RENDERENGINE]\n    renderdata[c4d.RDATA_RENDERENGINE] = c4d.RDATA_RENDERENGINE_PREVIEWHARDWARE\n\n    # Set render settings\n    for attr, value in PLAYBLAST_SETTINGS.items():\n        renderdata[getattr(c4d, attr)] = value\n\n    # Set FPS and frame range\n    renderdata[c4d.RDATA_FRAMERATE] = fps\n    renderdata[c4d.RDATA_FRAMESEQUENCE] = c4d.RDATA_FRAMESEQUENCE_MANUAL\n    renderdata[c4d.RDATA_FRAMEFROM] = frame_start\n    renderdata[c4d.RDATA_FRAMETO] = frame_end\n\n    # Set resolution\n    renderdata[c4d.RDATA_XRES] = width\n    renderdata[c4d.RDATA_YRES] = height\n\n    renderdata[c4d.RDATA_ALPHACHANNEL] = True\n\n    # TODO: Somehow figure out how to (temporarily) overwrite a video post,\n    #    or add a new one and remove it afterwards.\n    # Set hardware video post\n    # hardware_vp = c4d.documents.BaseVideoPost(c4d.RDATA_RENDERENGINE_PREVIEWHARDWARE)\n    # for k, v in HARDWARE_SETTINGS.items():\n    #     hardware_vp[getattr(c4d, k)] = v\n    # renderdata.InsertVideoPost(hardware_vp)\n    bmp = c4d.bitmaps.BaseBitmap()\n    bmp.Init(x=width, y=height, depth=24)\n    if bmp is None:\n        raise RenderError(\n            \"An error occurred during rendering: could not create bitmap.\"\n        )\n\n    renderdata.SetFilename(c4d.RDATA_PATH, filepath)\n\n    # Renders the document\n    result = c4d.documents.RenderDocument(\n        doc,\n        renderdata,\n        bmp,\n        c4d.RENDERFLAGS_EXTERNAL | c4d.RENDERFLAGS_NODOCUMENTCLONE,\n    )\n    if result != c4d.RENDERRESULT_OK:\n        raise RenderError(\n            \"Failed to render {filepath}. (error code: {result})\".format(\n                filepath=filepath, result=result\n            )\n        )\n\n    # Switch back to previous render engine,\n    # although this doesn't seem to be needed.\n    renderdata[c4d.RDATA_RENDERENGINE] = previous_render_engine\n    return filepath\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html","title":"lib","text":"<p>Library functions for Cinema4d.</p>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.active_document","title":"<code>active_document()</code>","text":"<p>Get the active Cinema4d document.</p> <p>Returns:</p> Type Description <p>c4d.documents.BaseDocument: The active document.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def active_document():\n    \"\"\"Get the active Cinema4d document.\n\n    Returns:\n        c4d.documents.BaseDocument: The active document.\n    \"\"\"\n\n    return c4d.documents.GetActiveDocument()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.add_objects_to_container","title":"<code>add_objects_to_container(container, nodes)</code>","text":"<p>Add the nodes to the container.</p> <p>A container in Cinema4d is a selection object. We have to get the so called InExcludeData and add the objects to it.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <p>The Avalon container to add the nodes to</p> required <code>nodes</code> <code>list</code> <p>The nodes to add to the container</p> required Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def add_objects_to_container(container, nodes):\n    \"\"\"Add the nodes to the container.\n\n    A container in Cinema4d is a selection object. We have to get the so called\n    InExcludeData and add the objects to it.\n\n    Args:\n        container: The Avalon container to add the nodes to\n        nodes (list): The nodes to add to the container\n    \"\"\"\n    in_exclude_data = container[c4d.SELECTIONOBJECT_LIST]\n    for node in nodes:\n        in_exclude_data.InsertObject(node, 1)\n    container[c4d.SELECTIONOBJECT_LIST] = in_exclude_data\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.collect_animation_defs","title":"<code>collect_animation_defs(create_context, fps=False)</code>","text":"<p>Get the basic animation attribute definitions for the publisher.</p> <p>Parameters:</p> Name Type Description Default <code>create_context</code> <code>CreateContext</code> <p>The context of publisher will be used to define the defaults for the attributes to use the current context's entity frame range as default values.</p> required <code>step</code> <code>bool</code> <p>Whether to include <code>step</code> attribute definition.</p> required <code>fps</code> <code>bool</code> <p>Whether to include <code>fps</code> attribute definition.</p> <code>False</code> <p>Returns:</p> Type Description <p>List[NumberDef]: List of number attribute definitions.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def collect_animation_defs(create_context, fps=False):\n    \"\"\"Get the basic animation attribute definitions for the publisher.\n\n    Arguments:\n        create_context (CreateContext): The context of publisher will be\n            used to define the defaults for the attributes to use the current\n            context's entity frame range as default values.\n        step (bool): Whether to include `step` attribute definition.\n        fps (bool): Whether to include `fps` attribute definition.\n\n    Returns:\n        List[NumberDef]: List of number attribute definitions.\n\n    \"\"\"\n\n    # use task entity attributes to set defaults based on current context\n    task_entity = create_context.get_current_task_entity()\n    attrib: dict = task_entity[\"attrib\"]\n    frame_start: int = attrib[\"frameStart\"]\n    frame_end: int = attrib[\"frameEnd\"]\n    handle_start: int = attrib[\"handleStart\"]\n    handle_end: int = attrib[\"handleEnd\"]\n\n    # build attributes\n    defs = [\n        NumberDef(\"frameStart\",\n                  label=\"Frame Start\",\n                  default=frame_start,\n                  decimals=0),\n        NumberDef(\"frameEnd\",\n                  label=\"Frame End\",\n                  default=frame_end,\n                  decimals=0),\n        NumberDef(\"handleStart\",\n                  label=\"Handle Start\",\n                  tooltip=\"Frames added before frame start to use as handles.\",\n                  default=handle_start,\n                  decimals=0),\n        NumberDef(\"handleEnd\",\n                  label=\"Handle End\",\n                  tooltip=\"Frames added after frame end to use as handles.\",\n                  default=handle_end,\n                  decimals=0),\n    ]\n\n    if fps:\n        doc = active_document()\n        current_fps = doc.GetFps()\n        fps_def = NumberDef(\n            \"fps\", label=\"FPS\", default=current_fps, decimals=5\n        )\n        defs.append(fps_def)\n\n    return defs\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.get_all_children","title":"<code>get_all_children(obj)</code>","text":"<p>Returns all children of an object, including grandchildren.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def get_all_children(obj):\n    \"\"\"Returns all children of an object, including grandchildren.\"\"\"\n    return list(iter_all_children(obj))\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.get_materials_from_objects","title":"<code>get_materials_from_objects(objects)</code>","text":"<p>Get the materials assigned to the objects.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>List[BaseObject]</code> <p>Objects to get materials for.</p> required <p>Returns:</p> Type Description <p>List[c4d.BaseMaterial]: List of assigned materials.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def get_materials_from_objects(objects):\n    \"\"\"Get the materials assigned to the objects.\n\n    Arguments:\n        objects (List[c4d.BaseObject]): Objects to get materials for.\n\n    Returns:\n        List[c4d.BaseMaterial]: List of assigned materials.\n    \"\"\"\n\n    materials = []\n    for obj in objects:\n        material_tags = [\n            tag for tag in obj.GetTags() if tag.GetTypeName() == \"Material\"\n        ]\n        for material_tag in material_tags:\n            material = material_tag.GetMaterial()\n            if material:\n                materials.append(material)\n\n    return materials\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.get_objects_from_container","title":"<code>get_objects_from_container(container, existing_only=True)</code>","text":"<p>Get the objects from the container.</p> <p>A container in Cinema4d is a selection object. We have to get the so called InExcludeData, get the object count and then get the objects at the indices.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>BaseObject</code> <p>The object containing selections.</p> required <p>Returns:</p> Name Type Description <code>generator</code> <p>The objects in the selection object.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def get_objects_from_container(container, existing_only=True):\n    \"\"\"Get the objects from the container.\n\n    A container in Cinema4d is a selection object. We have to get the so called\n    InExcludeData, get the object count and then get the objects at the indices.\n\n    Arguments:\n        container (c4d.BaseObject): The object containing selections.\n\n    Returns:\n        generator: The objects in the selection object.\n    \"\"\"\n    doc: c4d.documents.BaseDocument = container.GetMain()\n    assert isinstance(doc, c4d.documents.BaseDocument)\n    in_exclude_data = container[c4d.SELECTIONOBJECT_LIST]\n\n    # If the container is not a selection object list yield no child objects\n    if not in_exclude_data:\n        return\n\n    object_count = in_exclude_data.GetObjectCount()\n    for i in range(object_count):\n        obj = in_exclude_data.ObjectFromIndex(doc, i)\n        if existing_only and not obj:\n            continue\n\n        yield obj\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.get_unique_namespace","title":"<code>get_unique_namespace(folder_name, prefix=None, suffix=None, doc=None)</code>","text":"<p>Get a unique namespace for a newly loaded asset.</p> <p>Go through all loaded assets and if a loaded asset with the same name in encountered, go 1 version higher. So for example if you load 'foo' and there is already a 'foo_01', set the namespace to 'foo_02'.</p> <p>You can optionally set a prefix or suffix.</p> <p>Parameters:</p> Name Type Description Default <code>folder_name</code> <code>str</code> <p>The name of the folder.</p> required <code>prefix</code> <code>optional str</code> <p>An optional prefix for the namespace.</p> <code>None</code> <code>suffix</code> <code>optional str</code> <p>An optional suffix for the namespace.</p> <code>None</code> <code>doc</code> <code>optional c4d.documents.BaseDocument</code> <p>Optional Cinema4d document to work on. Default is the active document.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The unique namespace.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def get_unique_namespace(folder_name, prefix=None, suffix=None, doc=None):\n    \"\"\"Get a unique namespace for a newly loaded asset.\n\n    Go through all loaded assets and if a loaded asset with the same name in\n    encountered, go 1 version higher. So for example if you load 'foo'\n    and there is already a 'foo_01', set the namespace to 'foo_02'.\n\n    You can optionally set a prefix or suffix.\n\n    Arguments:\n        folder_name (str): The name of the folder.\n        prefix (optional str): An optional prefix for the namespace.\n        suffix (optional str): An optional suffix for the namespace.\n        doc (optional c4d.documents.BaseDocument): Optional Cinema4d document\n            to work on. Default is the active document.\n\n    Returns:\n        str: The unique namespace.\n    \"\"\"\n    doc = doc or active_document()\n    prefix = prefix or \"\"\n    suffix = suffix or \"\"\n    iteration = 1\n    unique = \"{prefix}{asset_name}_{iteration:02d}{suffix}\".format(\n        prefix=prefix,\n        asset_name=folder_name,\n        iteration=iteration,\n        suffix=suffix,\n    )\n\n    while doc.SearchObject(unique):\n        iteration += 1\n        unique = \"{prefix}{asset_name}_{iteration:02d}{suffix}\".format(\n            prefix=prefix,\n            asset_name=folder_name,\n            iteration=iteration,\n            suffix=suffix,\n        )\n\n    return unique\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.imprint","title":"<code>imprint(node, data, group=None)</code>","text":"<p>Write <code>data</code> to <code>node</code> as userDefined attributes</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>BaseObject</code> <p>The selection object</p> required <code>data</code> <code>dict</code> <p>Dictionary of key/value pairs</p> required Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def imprint(node, data, group=None):\n    \"\"\"Write `data` to `node` as userDefined attributes\n\n    Arguments:\n        node (c4d.BaseObject): The selection object\n        data (dict): Dictionary of key/value pairs\n    \"\"\"\n\n    existing_user_data = node.GetUserDataContainer()\n    existing_to_id = {}\n    for description_id, base_container in existing_user_data:\n        key = base_container[c4d.DESC_NAME]\n        existing_to_id[key] = description_id\n\n    # If `group` is specified, find the group to add new attributes to.\n    group_id = None\n    if group:\n        # Search the group first, if it does not exist, create it.\n        for description_id, base_container in existing_user_data:\n            name = base_container[c4d.DESC_NAME]\n            if name == group and description_id[1].dtype == c4d.DTYPE_GROUP:\n                group_id = description_id\n                break\n        else:\n            # Create the group\n            group_bc = c4d.GetCustomDatatypeDefault(c4d.DTYPE_GROUP)\n            group_bc[c4d.DESC_NAME] = group\n            group_bc[c4d.DESC_SHORT_NAME] = group\n            group_bc[c4d.DESC_TITLEBAR] = True\n            group_bc[c4d.DESC_GUIOPEN] = False\n            group_id = node.AddUserData(group_bc)\n\n    for key, value in data.items():\n\n        if callable(value):\n            # Support values evaluated at imprint\n            value = value()\n\n        if isinstance(value, bool):\n            add_type = c4d.DTYPE_BOOL\n        elif isinstance(value, str):\n            add_type = c4d.DTYPE_STRING\n        elif isinstance(value, int):\n            add_type = c4d.DTYPE_LONG\n        elif isinstance(value, float):\n            add_type = c4d.DTYPE_REAL\n        elif isinstance(value, (dict, list)):\n            add_type = c4d.DTYPE_STRING\n            value = f\"{JSON_PREFIX}{json.dumps(value)}\"\n        else:\n            raise TypeError(\n                f\"Unsupported type for {key}: {value} ({type(value)})\")\n\n        if key in existing_to_id:\n            # Set existing\n            element = existing_to_id[key]\n        else:\n            # Create new\n            base_container = c4d.GetCustomDataTypeDefault(add_type)\n            base_container[c4d.DESC_NAME] = key\n            base_container[c4d.DESC_SHORT_NAME] = key\n            base_container[c4d.DESC_ANIMATE] = c4d.DESC_ANIMATE_OFF\n            if group_id:\n                base_container[c4d.DESC_PARENTGROUP] = group_id\n\n            element = node.AddUserData(base_container)\n\n        node[element] = value\n\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.iter_all_children","title":"<code>iter_all_children(obj)</code>","text":"<p>Yield all children of an object, including grandchildren.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def iter_all_children(obj):\n    \"\"\"Yield all children of an object, including grandchildren.\"\"\"\n    stack = obj.GetChildren()\n    while stack:\n        child_obj = stack.pop()\n        stack.extend(child_obj.GetChildren())\n        yield child_obj\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n\n    doc = active_document()\n    previous_selection = doc.GetSelection()\n    try:\n        yield\n    finally:\n        set_selection(doc, previous_selection)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.obj_user_data_to_dict","title":"<code>obj_user_data_to_dict(obj)</code>","text":"<p>Construct a simple dictionary from the user data.</p> <p>Convert the user data to a dictionary so it's easier to work with.</p> <p>Returns:</p> Type Description <code>dict</code> <p>dict[str, Any]: User data of object..</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def obj_user_data_to_dict(obj) -&gt; dict:\n    \"\"\"Construct a simple dictionary from the user data.\n\n    Convert the user data to a dictionary so it's easier to work with.\n\n    Returns:\n        dict[str, Any]: User data of object..\n\n    \"\"\"\n    if not obj.GetUserDataContainer():\n        return None\n\n    user_data = {}\n\n    for description_id, base_container in obj.GetUserDataContainer():\n        key = base_container[c4d.DESC_NAME]\n\n        try:\n            value = obj[description_id]\n        except AttributeError:\n            # Fix #23: Silently ignore values that are not wrapped to Python\n            #  because we know user data we are interested in isn't any of\n            #  those anyway. Avoids object unknown in Python error.\n            continue\n\n        user_data[key] = value\n\n    return user_data\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.read","title":"<code>read(node)</code>","text":"<p>Return user-defined attributes from <code>node</code></p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def read(node) -&gt; dict:\n    \"\"\"Return user-defined attributes from `node`\"\"\"\n\n    data = obj_user_data_to_dict(node)\n\n    # data can be None, if so just return it\n    if data is None:\n        return {}\n\n    data = {\n        key: value\n        for key, value in data.items()\n        # Ignore hidden/internal data\n        if not key.startswith(\"_\")\n        # Ignore values that are None (e.g. groups in user data)\n        and value is not None\n    }\n\n    for key, value in data.items():\n        if isinstance(value, str) and value.startswith(JSON_PREFIX):\n            data[key] = json.loads(value[len(JSON_PREFIX):])\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.set_frame_range_from_entity","title":"<code>set_frame_range_from_entity(task_entity, doc=None)</code>","text":"<p>Set scene FPS adn resolution from task entity</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def set_frame_range_from_entity(task_entity, doc=None):\n    \"\"\"Set scene FPS adn resolution from task entity\"\"\"\n    if doc is None:\n        doc = active_document()\n    attrib = task_entity[\"attrib\"]\n\n    # get handles values\n    handle_start = int(attrib[\"handleStart\"])\n    handle_end = int(attrib[\"handleEnd\"])\n\n    f_fps = float(attrib[\"fps\"])\n    i_fps = int(math.ceil(attrib[\"fps\"]))\n    frame_start = int(attrib[\"frameStart\"]) - handle_start\n    frame_end = int(attrib[\"frameEnd\"]) + handle_end\n    bt_frame_start = c4d.BaseTime(frame_start, i_fps)\n    bt_frame_end = c4d.BaseTime(frame_end, i_fps)\n\n    # set document fps\n    doc.SetFps(i_fps)\n\n    # set document frame range\n    doc.SetMinTime(bt_frame_start)\n    doc.SetMaxTime(bt_frame_end)\n    doc.SetLoopMinTime(bt_frame_start)\n    doc.SetLoopMaxTime(bt_frame_end)\n\n    rd = doc.GetFirstRenderData()\n\n    while rd:\n        # set render fps\n        rd[c4d.RDATA_FRAMERATE] = f_fps\n        # set render frame range\n        rd[c4d.RDATA_FRAMEFROM] = bt_frame_start\n        rd[c4d.RDATA_FRAMETO] = bt_frame_end\n        rd = rd.GetNext()\n\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.set_resolution_from_entity","title":"<code>set_resolution_from_entity(task_entity, doc=None)</code>","text":"<p>Set render resolution from task entity</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>def set_resolution_from_entity(task_entity, doc=None):\n    \"\"\"Set render resolution from task entity\"\"\"\n    if doc is None:\n        doc = active_document()\n\n    attrib = task_entity[\"attrib\"]\n    width: int = int(attrib[\"resolutionWidth\"])\n    height: int = int(attrib[\"resolutionHeight\"])\n    pixel_aspect: float = attrib[\"pixelAspect\"]\n\n    @contextlib.contextmanager\n    def _unlocked_ratio(render_data):\n        \"\"\"Temporarily unlock the ratio of the render resolution.\"\"\"\n        original = render_data[c4d.RDATA_LOCKRATIO]\n        render_data[c4d.RDATA_LOCKRATIO] = False\n        try:\n            yield\n        finally:\n            render_data[c4d.RDATA_LOCKRATIO] = original\n\n    rd = doc.GetFirstRenderData()\n    while rd:\n        # Fix #20: Set the virtual resolution with user interaction so Redshift\n        # still triggers some additional checks on the attribute change.\n        with _unlocked_ratio(rd):\n            flag = c4d.DESCFLAGS_SET_USERINTERACTION\n            rd.SetParameter(c4d.RDATA_XRES_VIRTUAL, width, flag)\n            rd.SetParameter(c4d.RDATA_YRES_VIRTUAL, height, flag)\n\n        # Set pixel aspect ratio\n        rd[c4d.RDATA_PIXELASPECT] = pixel_aspect\n\n        rd = rd.GetNext()\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib.html#client.ayon_cinema4d.api.lib.undo_chunk","title":"<code>undo_chunk()</code>","text":"<p>Open a undo chunk during context.</p> Source code in <code>client/ayon_cinema4d/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef undo_chunk():\n    \"\"\"Open a undo chunk during context.\"\"\"\n    doc = active_document()\n    try:\n        doc.StartUndo()\n        yield\n    finally:\n        doc.EndUndo()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html","title":"lib_renderproducts","text":""},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.AOV","title":"<code>AOV</code>","text":"<p>Dataclass for AOVs</p> <p>This should hold all the data to be able to define the resolved path.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>@attr.s\nclass AOV:\n    \"\"\"Dataclass for AOVs\n\n    This should hold all the data to be able to define the resolved path.\n    \"\"\"\n    item: Any = attr.ib()  # The Redshift AOV object\n    enabled: bool = attr.ib()\n    name: str = attr.ib()\n    effective_name: str = attr.ib()\n    aov_type: int = attr.ib()\n    multipass_enabled: bool = attr.ib()    # Multi-pass Output enabled\n    direct_enabled: bool = attr.ib()       # Direct Output enabled\n    filepath: str = attr.ib()              # Direct Output path\n    file_effective_path: str = attr.ib()   # Effective path for direct output\n\n    @property\n    def layer_name(self) -&gt; str:\n        return self.effective_name\n\n    @property\n    def layer_type_name(self) -&gt; str:\n        return self.name\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.LayerMetadata","title":"<code>LayerMetadata</code>","text":"<p>               Bases: <code>object</code></p> <p>Data class for Render Layer metadata.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>@attr.s\nclass LayerMetadata(object):\n    \"\"\"Data class for Render Layer metadata.\"\"\"\n    frameStart = attr.ib()\n    frameEnd = attr.ib()\n    products: list[RenderProduct] = attr.ib(factory=list)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.RenderProduct","title":"<code>RenderProduct</code>","text":"<p>               Bases: <code>object</code></p> <p>Getting Colorspace as Specific Render Product Parameter for submitting publish job.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>@attr.s\nclass RenderProduct(object):\n    \"\"\"\n    Getting Colorspace as Specific Render Product Parameter for submitting\n    publish job.\n    \"\"\"\n    productName: str = attr.ib()   # AOV name or \"\" for Beauty\n    colorspace: str = attr.ib()  # Render Colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.apply_name_format","title":"<code>apply_name_format(path, name_format, file_format, frame=0)</code>","text":"<p>Apply the C4D render data name format to the given filepath.</p> Reference <p>RDATA_NAMEFORMAT_0 = Name0000.TIF RDATA_NAMEFORMAT_1 = Name0000 RDATA_NAMEFORMAT_2 = Name.0000 RDATA_NAMEFORMAT_3 = Name000.TIF RDATA_NAMEFORMAT_4 = Name000 RDATA_NAMEFORMAT_5 = Name.000 RDATA_NAMEFORMAT_6 = Name.0000.TIF</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> required <code>name_format</code> <code>int</code> required <code>file_format</code> <code>int</code> required <code>frame</code> <code>int</code> <code>0</code> <p>Returns:</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>def apply_name_format(\n    path: str,\n    name_format: int,\n    file_format: int,\n    frame: int = 0\n) -&gt; str:\n    \"\"\"Apply the C4D render data name format to the given filepath.\n\n    Reference:\n        RDATA_NAMEFORMAT_0 = Name0000.TIF\n        RDATA_NAMEFORMAT_1 = Name0000\n        RDATA_NAMEFORMAT_2 = Name.0000\n        RDATA_NAMEFORMAT_3 = Name000.TIF\n        RDATA_NAMEFORMAT_4 = Name000\n        RDATA_NAMEFORMAT_5 = Name.000\n        RDATA_NAMEFORMAT_6 = Name.0000.TIF\n\n    Args:\n        path:\n        name_format:\n        file_format:\n        frame:\n\n    Returns:\n\n    \"\"\"\n    head, _ = os.path.splitext(path)\n    try:\n        padding: int = {\n            c4d.RDATA_NAMEFORMAT_0: 4,\n            c4d.RDATA_NAMEFORMAT_1: 4,\n            c4d.RDATA_NAMEFORMAT_2: 4,\n            c4d.RDATA_NAMEFORMAT_3: 3,\n            c4d.RDATA_NAMEFORMAT_4: 3,\n            c4d.RDATA_NAMEFORMAT_5: 3,\n            c4d.RDATA_NAMEFORMAT_6: 4,\n        }[name_format]\n    except KeyError as exc:\n        raise ValueError(f\"Unsupported name format: {name_format}\") from exc\n    frame_str = str(frame).zfill(padding)\n\n    # Prefix frame number with a dot for specific name formats\n    if name_format in {\n        c4d.RDATA_NAMEFORMAT_2,\n        c4d.RDATA_NAMEFORMAT_5,\n        c4d.RDATA_NAMEFORMAT_6,\n    }:\n        frame_str = \".\" + frame_str\n    # Whenever the frame number directly follows the name and the name ends\n    # with a digit then C4D adds an underscore before the frame number.\n    elif head and head[-1].isdigit():\n        frame_str = \"_\" + frame_str\n\n    # Add file format extension if name format includes it\n    if name_format in {\n        c4d.RDATA_NAMEFORMAT_0,\n        c4d.RDATA_NAMEFORMAT_3,\n        c4d.RDATA_NAMEFORMAT_6,\n    }:\n        extension: str = get_renderdata_file_format_extension(file_format)\n    else:\n        # No extension\n        extension: str = \"\"\n\n    return f\"{head}{frame_str}{extension}\"\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.find_video_post","title":"<code>find_video_post(render_data, plugin_id)</code>","text":"<p>Find first video post with plugin_id in render data.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>def find_video_post(\n        render_data: c4d.documents.RenderData, plugin_id: int\n) -&gt; Optional[c4d.documents.BaseVideoPost]:\n    \"\"\"Find first video post with plugin_id in render data.\"\"\"\n    vp = render_data.GetFirstVideoPost()\n    while vp is not None:\n        if vp.IsInstanceOf(plugin_id):\n            return vp\n        vp = vp.GetNext()\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.get_default_ocio_resource","title":"<code>get_default_ocio_resource()</code>","text":"<p>Return default OCIO config path for Cinema4D.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>def get_default_ocio_resource() -&gt; str:\n    \"\"\"Return default OCIO config path for Cinema4D.\"\"\"\n    resources = c4d.storage.GeGetC4DPath(c4d.C4D_PATH_RESOURCE)\n    return os.path.join(resources, \"ocio\", \"config.ocio\")\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.get_multipasses","title":"<code>get_multipasses(render_data)</code>","text":"<p>Return all multipasses in render data.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>def get_multipasses(\n        render_data: c4d.documents.RenderData,\n) -&gt; list[c4d.BaseList2D]:\n    \"\"\"Return all multipasses in render data.\"\"\"\n    multipasses = []\n    multipass = render_data.GetFirstMultipass()\n    while multipass is not None:\n        multipasses.append(multipass)\n        multipass = multipass.GetNext()\n    return multipasses\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.get_renderdata_file_format_extension","title":"<code>get_renderdata_file_format_extension(file_format)</code>","text":"<p>Get the file extension for a given render data file format.</p> <p>The file format is e.g. render data like:     - c4d.RDATA_FORMAT     - c4d.RDATA_MULTIPASS_SAVEFORMAT</p> <p>Parameters:</p> Name Type Description Default <code>file_format</code> <code>int</code> <p>The C4D render data file format constant.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A file extension.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>def get_renderdata_file_format_extension(file_format: int) -&gt; str:\n    \"\"\"Get the file extension for a given render data file format.\n\n    The file format is e.g. render data like:\n        - c4d.RDATA_FORMAT\n        - c4d.RDATA_MULTIPASS_SAVEFORMAT\n\n    Args:\n        file_format: The C4D render data file format constant.\n\n    Returns:\n        str: A file extension.\n    \"\"\"\n    try:\n        return {\n            c4d.FILTER_AVI: \".avi\",\n            c4d.FILTER_B3D: \".b3d\",\n            c4d.FILTER_B3DNET: \".b3d\",\n            c4d.FILTER_BMP: \".bmp\",\n            c4d.FILTER_DDS: \".dds\",\n            c4d.FILTER_DPX: \".dpx\",\n            c4d.FILTER_EXR: \".exr\",\n            c4d.FILTER_HDR: \".hdr\",\n            c4d.FILTER_IES: \".ies\",\n            c4d.FILTER_IFF: \".iff\",\n            c4d.FILTER_JPG: \".jpg\",\n            c4d.FILTER_PICT: \".pict\",\n            c4d.FILTER_PNG: \".png\",\n            c4d.FILTER_PSB: \".psb\",\n            c4d.FILTER_PSD: \".psd\",\n            c4d.FILTER_RLA: \".rla\",\n            c4d.FILTER_RPF: \".rpf\",\n            c4d.FILTER_TGA: \".tga\",\n            c4d.FILTER_TIF: \".tif\",\n            c4d.FILTER_TIF_B3D: \".tif\",\n        }[file_format]\n    except KeyError as exc:\n        raise ValueError(f\"Unsupported file format: {file_format}\") from exc\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.iter_redshift_aovs","title":"<code>iter_redshift_aovs(video_post)</code>","text":"<p>Using a Video Post from Redshift render yield all Redshift AOVs.</p> <p>This may separate light-groups into separate AOVs.</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>def iter_redshift_aovs(video_post: c4d.documents.BaseVideoPost) -&gt; Generator[AOV, None, None]:\n    \"\"\"Using a Video Post from Redshift render yield all Redshift AOVs.\n\n    This may separate light-groups into separate AOVs.\n    \"\"\"\n    aovs = redshift.RendererGetAOVs(video_post)\n    scene_light_groups = get_redshift_light_groups(video_post.GetDocument())\n\n    for aov in aovs:\n        # Redshift Cryptomatte is always separate\n        global_aov = AOV(\n            item=aov,\n            name=aov.GetParameter(c4d.REDSHIFT_AOV_NAME),\n            effective_name=aov.GetParameter(c4d.REDSHIFT_AOV_EFFECTIVE_NAME),\n            aov_type=aov.GetParameter(c4d.REDSHIFT_AOV_TYPE),\n            enabled=bool(aov.GetParameter(c4d.REDSHIFT_AOV_ENABLED)),\n            multipass_enabled=bool(\n                aov.GetParameter(c4d.REDSHIFT_AOV_MULTIPASS_ENABLED)),\n            direct_enabled=bool(aov.GetParameter(c4d.REDSHIFT_AOV_FILE_ENABLED)),\n            filepath=aov.GetParameter(c4d.REDSHIFT_AOV_FILE_PATH),\n            file_effective_path=aov.GetParameter(\n                c4d.REDSHIFT_AOV_FILE_EFFECTIVE_PATH)\n        )\n\n        if global_aov.effective_name == \"Z\":\n            # Z AOV gets merged into main layer?\n            continue\n\n        # The list of returned light group names may contain 'unused' entries\n        # that do not exist (anymore?) so we must filter the list against the\n        # scene light groups.\n        light_groups: list[str] = [\n            lg.strip() for lg in\n            aov.GetParameter(c4d.REDSHIFT_AOV_LIGHTGROUP_NAMES).split(\"\\n\")\n        ]\n        light_groups = [\n            lg for lg in light_groups if lg and lg in scene_light_groups\n        ]\n        all_light_groups: bool = aov.GetParameter(c4d.REDSHIFT_AOV_LIGHTGROUP_ALL)\n        if all_light_groups:\n            light_groups = list(scene_light_groups)\n\n        light_group_mode: int = aov.GetParameter(c4d.REDSHIFT_AOV_LIGHTGROUP_GLOBALAOV)  # noqa\n\n        # Global AOV (Main output)\n        if not light_groups or light_group_mode == c4d.REDSHIFT_AOV_LIGHTGROUP_GLOBALAOV_ALL:\n            yield global_aov\n\n        # Global Remainder AOV\n        if light_groups and light_group_mode == c4d.REDSHIFT_AOV_LIGHTGROUP_GLOBALAOV_REMAINDER:\n            remainder_aov = copy.copy(global_aov)\n            # Only specify name if already set\n            if remainder_aov.name:\n                remainder_aov.name += \"_other\"\n            remainder_aov.effective_name += \"_other\"\n            yield remainder_aov\n\n        # AOV output per light group\n        for light_group in light_groups:\n            light_aov = copy.copy(global_aov)\n            if light_aov.name:\n                light_aov.name += f\"_{light_group}\"\n            light_aov.effective_name += f\"_{light_group}\"\n            yield light_aov\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/lib_renderproducts.html#client.ayon_cinema4d.api.lib_renderproducts.resolve_filepath","title":"<code>resolve_filepath(token_path, doc=None, render_data=None, render_settings=None, frame=None, take=None, layer_name=None, layer_type_name=None, layer_type=None)</code>","text":"<p>Resolve a path with tokens to a resolved path.</p> <p>See: https://developers.maxon.net/docs/py/2024_4_0a/modules/c4d.modules/tokensystem/index.html  # noqa</p> <p>Constructs the <code>rpData (RenderPathData)</code> dictionary:     _doc: BaseDocument     -&gt; $prj     _rData: RenderData     -&gt; $res, $height, $rs, $renderer     _rBc: BaseContainer     _take: BaseTake        -&gt; $take     _frame: int            -&gt; $frame     _layerName: str        -&gt; $userpass     _layerTypeName: str    -&gt; $pass     _layerType: int     _isLight: bool     _lightNumber: int     _isMaterial: bool     _nodeName: str     _checkUnresolved: bool</p> Source code in <code>client/ayon_cinema4d/api/lib_renderproducts.py</code> <pre><code>def resolve_filepath(\n    token_path: str,\n    doc: Optional[c4d.documents.BaseDocument] = None,\n    render_data: Optional[c4d.documents.RenderData] = None,\n    render_settings: Optional[c4d.BaseContainer] = None,\n    frame: Optional[int] = None,\n    take: Optional[c4d.modules.takesystem.BaseTake] = None,\n    layer_name: Optional[str] = None,\n    layer_type_name: Optional[str] = None,\n    layer_type: Optional[int] = None,\n) -&gt; str:\n    \"\"\"Resolve a path with tokens to a resolved path.\n\n    See: https://developers.maxon.net/docs/py/2024_4_0a/modules/c4d.modules/tokensystem/index.html  # noqa\n\n    Constructs the `rpData (RenderPathData)` dictionary:\n        _doc: BaseDocument     -&gt; $prj\n        _rData: RenderData     -&gt; $res, $height, $rs, $renderer\n        _rBc: BaseContainer\n        _take: BaseTake        -&gt; $take\n        _frame: int            -&gt; $frame\n        _layerName: str        -&gt; $userpass\n        _layerTypeName: str    -&gt; $pass\n        _layerType: int\n        _isLight: bool\n        _lightNumber: int\n        _isMaterial: bool\n        _nodeName: str\n        _checkUnresolved: bool\n    \"\"\"\n    if doc is None:\n        doc = c4d.documents.GetActiveDocument()\n    if render_data is None:\n        render_data = doc.GetActiveRenderData()\n    if render_settings is None:\n        render_settings = render_data.GetDataInstance()\n    if frame is None:\n        frame = doc.GetTime().GetFrame(doc.GetFps())\n    if take is None:\n        take = doc.GetTakeData().GetCurrentTake()\n\n    rpd = {\n        \"_doc\": doc,\n        \"_rData\": render_data,\n        \"_rBc\": render_settings,\n        \"_frame\": frame,\n    }\n    optionals = {\n        \"_take\": take,\n        \"_layerName\": layer_name,\n        \"_layerTypeName\": layer_type_name,\n        \"_layerType\": layer_type,\n    }\n    for key, value in optionals.items():\n        if value is not None:\n            rpd[key] = value\n\n    # When passing the token itself as the value for a token, e.g. $pass=$pass\n    # it may hang Cinema4D. So, we swap those out to placeholders to replace\n    # after resolving.\n    placeholders = {}\n    for key, value in rpd.items():\n        if isinstance(value, str) and \"$\" in value:\n            placeholder = f\"____{key.upper()}__PLACEHOLDER____\"\n            placeholders[value] = placeholder\n            rpd[key] = placeholder\n\n    resolved = c4d.modules.tokensystem.StringConvertTokens(token_path, rpd)\n    for value, placeholder in placeholders.items():\n        resolved = resolved.replace(placeholder, value)\n    return resolved\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_cinema4d/api/pipeline.html#client.ayon_cinema4d.api.pipeline.containerise","title":"<code>containerise(name, namespace, nodes, context, loader, suffix='_CON')</code>","text":"<p>Bundle <code>nodes</code> into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>list</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> required <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'_CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <code>BaseObject</code> <p>OSelection BaseObject container</p> Source code in <code>client/ayon_cinema4d/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 nodes,\n                 context,\n                 loader,\n                 suffix=\"_CON\"):\n    \"\"\"Bundle `nodes` into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        nodes (list): Long names of nodes to containerise\n        context (dict): Asset information\n        loader (str): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (c4d.BaseObject): OSelection BaseObject container\n\n    \"\"\"\n\n    container_name = lib.get_unique_namespace(\n        name,\n        prefix=namespace + \"_\",\n        suffix=suffix\n    )\n    with lib.undo_chunk():\n        container = c4d.BaseObject(c4d.Oselection)\n        container.SetName(container_name)\n        in_exclude_data = container[c4d.SELECTIONOBJECT_LIST]\n        for node in nodes:\n            in_exclude_data.InsertObject(node, 1)\n        container[c4d.SELECTIONOBJECT_LIST] = in_exclude_data\n        doc = lib.active_document()\n        doc.InsertObject(container)\n\n        imprint_container(\n            container,\n            name,\n            namespace,\n            context,\n            loader\n        )\n\n        # Add the container to the AYON_CONTAINERS layer\n        avalon_layer = get_containers_layer(doc=doc)\n        container.SetLayerObject(avalon_layer)\n        # Hide the container in the Object Manager\n        # container.ChangeNBit(c4d.NBIT_OHIDE, c4d.NBITCONTROL_SET)\n        c4d.EventAdd()\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/pipeline.html#client.ayon_cinema4d.api.pipeline.get_containers_layer","title":"<code>get_containers_layer(doc=None)</code>","text":"<p>Get the layer that holds all container objects.</p> <p>To make the scene less cluttered the containers (selection objects) are put in a layer 'AYON_CONTAINERS'. This layer is hidden in the outliner.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>optional c4d.documents.BaseDocument</code> <p>The document to work on. If it is None it uses the active document.</p> <code>None</code> Source code in <code>client/ayon_cinema4d/api/pipeline.py</code> <pre><code>def get_containers_layer(doc=None):\n    \"\"\"Get the layer that holds all container objects.\n\n    To make the scene less cluttered the containers (selection objects) are put\n    in a layer 'AYON_CONTAINERS'. This layer is hidden in the outliner.\n\n    Arguments:\n        doc (optional c4d.documents.BaseDocument): The document to work on. If\n            it is None it uses the active document.\n    \"\"\"\n\n    doc = doc or lib.active_document()\n    layer_root = doc.GetLayerObjectRoot()\n    for layer in layer_root.GetChildren():\n        if layer.GetName() == AYON_CONTAINERS:\n            return layer\n\n    layer = c4d.documents.LayerObject()\n    layer.SetName(AYON_CONTAINERS)\n    layer.InsertUnder(layer_root)\n    layer[c4d.ID_LAYER_MANAGER] = False\n    layer[c4d.ID_LAYER_VIEW] = False\n    layer[c4d.ID_LAYER_RENDER] = False\n    layer[c4d.ID_LAYER_COLOR] = c4d.Vector(0.3, 0.66, 0.96)\n    layer[c4d.ID_LAYER_LOCKED] = True\n\n    c4d.EventAdd()\n\n    return layer\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/pipeline.html#client.ayon_cinema4d.api.pipeline.imprint_container","title":"<code>imprint_container(container, name, namespace, context, loader)</code>","text":"<p>Imprints an object with container metadata and hides it from the user by adding it into a hidden layer. Arguments:     container (c4d.BaseObject): The object to imprint.     name (str): Name of resulting assembly     namespace (str): Namespace under which to host container     context (dict): Asset information     loader (str): Name of loader used to produce this container.</p> Source code in <code>client/ayon_cinema4d/api/pipeline.py</code> <pre><code>def imprint_container(\n    container,\n    name,\n    namespace,\n    context,\n    loader\n):\n    \"\"\"Imprints an object with container metadata and hides it from the user\n    by adding it into a hidden layer.\n    Arguments:\n        container (c4d.BaseObject): The object to imprint.\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str): Name of loader used to produce this container.\n    \"\"\"\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": str(context[\"representation\"][\"id\"]),\n    }\n\n    lib.imprint(container, data, group=\"AYON\")\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/pipeline.html#client.ayon_cinema4d.api.pipeline.iter_containers","title":"<code>iter_containers(doc=None)</code>","text":"<p>Yield all objects in the active document that have 'id' attribute set matching an AYON container ID</p> Source code in <code>client/ayon_cinema4d/api/pipeline.py</code> <pre><code>def iter_containers(doc=None):\n    \"\"\"Yield all objects in the active document that have 'id' attribute set\n    matching an AYON container ID\"\"\"\n    doc = doc or c4d.documents.GetActiveDocument()\n    containers = lib.iter_objects(doc.GetFirstObject())\n    for container in containers:\n        if lib.get_object_user_data_by_name(container, \"id\") != AYON_CONTAINER_ID:  # noqa\n            continue\n\n        data = parse_container(container)\n        yield data\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/pipeline.html#client.ayon_cinema4d.api.pipeline.parse_container","title":"<code>parse_container(container)</code>","text":"<p>Return the container node's full container data.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>str</code> <p>A container node name.</p> required <p>Returns:</p> Type Description <p>dict[str, Any]: The container schema data for this container node.</p> Source code in <code>client/ayon_cinema4d/api/pipeline.py</code> <pre><code>def parse_container(container):\n    \"\"\"Return the container node's full container data.\n\n    Args:\n        container (str): A container node name.\n\n    Returns:\n        dict[str, Any]: The container schema data for this container node.\n\n    \"\"\"\n    data = lib.read(container)\n\n    # Backwards compatibility pre-schemas for containers\n    data[\"schema\"] = data.get(\"schema\", \"ayon:container-3.0\")\n\n    # Append transient data\n    data[\"objectName\"] = container.GetName()\n    data[\"node\"] = container\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_cinema4d/api/plugin.html#client.ayon_cinema4d.api.plugin.Cinema4DLoader","title":"<code>Cinema4DLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> Source code in <code>client/ayon_cinema4d/api/plugin.py</code> <pre><code>class Cinema4DLoader(LoaderPlugin):\n    hosts = [\"cinema4d\"]\n    settings_category = \"cinema4d\"\n\n    def get_name_and_namespace(self, context, name, namespace, doc=None):\n        if doc is None:\n            doc = lib.active_document()\n\n        product_name = context[\"product\"][\"name\"]\n        folder_name: str = context[\"folder\"][\"name\"]\n        namespace = namespace or lib.get_unique_namespace(\n            folder_name,\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"\",\n            doc=doc,\n        )\n        name = name or product_name\n\n        return name, namespace\n\n    def remove(self, container):\n        \"\"\"Remove all sub containers\"\"\"\n        container_node = container[\"node\"]\n        for obj in lib.get_objects_from_container(container_node):\n            obj.Remove()\n        container_node.Remove()\n        c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/plugin.html#client.ayon_cinema4d.api.plugin.Cinema4DLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove all sub containers</p> Source code in <code>client/ayon_cinema4d/api/plugin.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove all sub containers\"\"\"\n    container_node = container[\"node\"]\n    for obj in lib.get_objects_from_container(container_node):\n        obj.Remove()\n    container_node.Remove()\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/plugin.html#client.ayon_cinema4d.api.plugin.Cinema4DSingleObjLoader","title":"<code>Cinema4DSingleObjLoader</code>","text":"<p>               Bases: <code>Cinema4DLoader</code>, <code>ABC</code></p> <p>Base Loader plug-in that manages a single Cinema4D object with a filepath parameter.</p> <p>Instead of containerizing on a hidden selection object this imprints the node itself as a container.</p> Source code in <code>client/ayon_cinema4d/api/plugin.py</code> <pre><code>class Cinema4DSingleObjLoader(Cinema4DLoader, ABC):\n    \"\"\"Base Loader plug-in that manages a single Cinema4D object with a\n    filepath parameter.\n\n    Instead of containerizing on a hidden selection object this imprints the\n    node itself as a container.\"\"\"\n\n    @property\n    @abstractmethod\n    def _node_type_id(self) -&gt; int:\n        \"\"\"The node type id to create and manage.\"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def _filepath_attribute(self) -&gt; \"Union[int, Tuple[int, int]]\":\n        \"\"\"Return the id for the filepath attribute on the node type.\n\n        This is usually an `int` constant, but for some nodes like Redshift\n        Proxies these are a tuple of two ids.\n\n        \"\"\"\n        pass\n\n    def set_obj_for_context(self, obj, context, is_update=False):\n        \"\"\"Update the object for the new context. This will be called on load\n        and update to configure the object for the new context, like setting\n        the filepath.\n\n        This can be inherited on child classes to do additional things on load\n        or update.\n\n        Arguments:\n            obj (c4d.BaseObject): The managed object.\n            context (dict[str, Any]): The full representation context.\n            is_update (bool): Whether this is part of an `update` call or\n                first `load`.\n\n        \"\"\"\n        filepath = self.filepath_from_context(context)\n        obj[self._filepath_attribute] = filepath\n\n    def load(self, context, name=None, namespace=None, options=None):\n\n        doc = lib.active_document()\n\n        name, namespace = self.get_name_and_namespace(\n            context, name, namespace, doc=doc)\n\n        # Create object\n        obj = c4d.BaseObject(self._node_type_id)\n        obj.SetName(name)\n        doc.InsertObject(obj)\n\n        self.set_obj_for_context(obj, context)\n\n        container = pipeline.imprint_container(\n            obj,\n            name=str(name),\n            namespace=str(namespace),\n            context=context,\n            loader=str(self.__class__.__name__),\n        )\n\n        c4d.EventAdd()\n\n        return container\n\n    def update(self, container, context):\n\n        obj = container[\"node\"]\n\n        # Update filepath\n        if obj.CheckType(self._node_type_id):\n            self.set_obj_for_context(obj, context)\n\n        # Update representation id\n        for i, base_container in obj.GetUserDataContainer():\n            if base_container[c4d.DESC_NAME] == \"representation\":\n                obj[i] = context[\"representation\"][\"id\"]\n\n        c4d.EventAdd()\n\n    def remove(self, container):\n        \"\"\"Remove all sub containers\"\"\"\n        container_node = container[\"node\"]\n        container_node.Remove()\n        c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/plugin.html#client.ayon_cinema4d.api.plugin.Cinema4DSingleObjLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove all sub containers</p> Source code in <code>client/ayon_cinema4d/api/plugin.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove all sub containers\"\"\"\n    container_node = container[\"node\"]\n    container_node.Remove()\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/plugin.html#client.ayon_cinema4d.api.plugin.Cinema4DSingleObjLoader.set_obj_for_context","title":"<code>set_obj_for_context(obj, context, is_update=False)</code>","text":"<p>Update the object for the new context. This will be called on load and update to configure the object for the new context, like setting the filepath.</p> <p>This can be inherited on child classes to do additional things on load or update.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>BaseObject</code> <p>The managed object.</p> required <code>context</code> <code>dict[str, Any]</code> <p>The full representation context.</p> required <code>is_update</code> <code>bool</code> <p>Whether this is part of an <code>update</code> call or first <code>load</code>.</p> <code>False</code> Source code in <code>client/ayon_cinema4d/api/plugin.py</code> <pre><code>def set_obj_for_context(self, obj, context, is_update=False):\n    \"\"\"Update the object for the new context. This will be called on load\n    and update to configure the object for the new context, like setting\n    the filepath.\n\n    This can be inherited on child classes to do additional things on load\n    or update.\n\n    Arguments:\n        obj (c4d.BaseObject): The managed object.\n        context (dict[str, Any]): The full representation context.\n        is_update (bool): Whether this is part of an `update` call or\n            first `load`.\n\n    \"\"\"\n    filepath = self.filepath_from_context(context)\n    obj[self._filepath_attribute] = filepath\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/plugin.html#client.ayon_cinema4d.api.plugin.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>","text":"<p>Cache instances for Creators shared data.</p> <p>Create <code>cinema4d_cached_instances</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>shared_data</code> <code>Dict[str, Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_cinema4d/api/plugin.py</code> <pre><code>def cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators shared data.\n\n    Create `cinema4d_cached_instances` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    Args:\n        shared_data(Dict[str, Any]): Shared data.\n\n    \"\"\"\n    if shared_data.get('cinema4d_cached_instances') is None:\n        cache = {}\n        doc = lib.active_document()\n        for creator_id, obj in iter_instance_objects(doc):\n            cache.setdefault(creator_id, []).append(obj)\n\n        shared_data[\"cinema4d_cached_instances\"] = cache\n\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/api/workio.html","title":"workio","text":"<p>Host API required Work Files tool</p>"},{"location":"autoapi/client/ayon_cinema4d/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_cinema4d/hooks/pre_pyside_install.html","title":"pre_pyside_install","text":""},{"location":"autoapi/client/ayon_cinema4d/hooks/pre_pyside_install.html#client.ayon_cinema4d.hooks.pre_pyside_install.InstallPySideToCinema4D","title":"<code>InstallPySideToCinema4D</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Automatically installs Qt binding to Cinema 4D's python packages.</p> <p>Check if Cinema 4D has installed PySide6 and will try to install if not.</p> <p>For pipeline implementation is required to have Qt binding installed in Cinema 4D's python packages.</p> Source code in <code>client/ayon_cinema4d/hooks/pre_pyside_install.py</code> <pre><code>class InstallPySideToCinema4D(PreLaunchHook):\n    \"\"\"Automatically installs Qt binding to Cinema 4D's python packages.\n\n    Check if Cinema 4D has installed PySide6 and will try to install if not.\n\n    For pipeline implementation is required to have Qt binding installed in\n    Cinema 4D's python packages.\n    \"\"\"\n\n    app_groups = {\"cinema4d\"}\n    order = 2\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # TODO: Enable this when we find a way to make it faster\n        return\n        # Prelaunch hook is not crucial\n        try:\n            # TODO: Add setting to enable/disable this\n            # settings = self.data[\"project_settings\"][self.host_name]\n            # if not settings[\"hooks\"][\"InstallPySideToCinema4d\"][\"enabled\"]:\n            #     return\n            self.inner_execute()\n        except Exception:\n            self.log.warning(\n                \"Processing of {} crashed.\".format(self.__class__.__name__),\n                exc_info=True\n            )\n\n    def inner_execute(self):\n        self.log.debug(\"Check for PySide6 installation.\")\n\n        # Find c4dpy executable\n        executable = self.launch_context.executable.executable_path\n        expected_executable = \"c4dpy\"\n        platform_name = platform.system().lower()\n        if platform_name == \"windows\":\n            expected_executable += \".exe\"\n        if os.path.basename(executable) != expected_executable:\n            folder = os.path.dirname(executable)\n            python_executable = os.path.join(folder, expected_executable)\n        else:\n            python_executable = executable\n\n        if not os.path.exists(python_executable):\n            self.log.warning(\n                \"Couldn't find python executable for Cinema4D. {}\".format(\n                    python_executable\n                )\n            )\n            return\n\n        # Check if PySide6 is installed and skip if yes\n        if self._is_pyside_installed(python_executable):\n            self.log.debug(\"Cinema4D has already installed PySide6.\")\n            return\n\n        self.log.debug(\"Installing PySide6.\")\n        # Install PySide6 in cinema4d's python\n        if self._windows_require_permissions(\n                os.path.dirname(python_executable)):\n            result = self._install_pyside_windows(python_executable)\n        else:\n            result = self._install_pyside(python_executable)\n\n        if result:\n            self.log.info(\"Successfully installed PySide6 module to cinema4d.\")\n        else:\n            self.log.warning(\"Failed to install PySide6 module to cinema4d.\")\n\n    def _install_pyside_windows(self, python_executable):\n        \"\"\"Install PySide6 python module to cinema4d's python.\n\n        Installation requires administration rights that's why it is required\n        to use \"pywin32\" module which can execute command's and ask for\n        administration rights.\n        \"\"\"\n        try:\n            import win32con\n            import win32process\n            import win32event\n            import pywintypes\n            from win32comext.shell.shell import ShellExecuteEx\n            from win32comext.shell import shellcon\n        except Exception:\n            self.log.warning(\"Couldn't import \\\"pywin32\\\" modules\")\n            return False\n\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide6 and argument\n            #   \"--ignore-installed\" is to force install module to cinema4d's\n            #   site-packages and make sure it is binary compatible\n            parameters = \"-m pip install --ignore-installed PySide6\"\n\n            # Execute command and ask for administrator's rights\n            process_info = ShellExecuteEx(\n                nShow=win32con.SW_SHOWNORMAL,\n                fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n                lpVerb=\"runas\",\n                lpFile=python_executable,\n                lpParameters=parameters,\n                lpDirectory=os.path.dirname(python_executable)\n            )\n            process_handle = process_info[\"hProcess\"]\n            win32event.WaitForSingleObject(process_handle,\n                                           win32event.INFINITE)\n            returncode = win32process.GetExitCodeProcess(process_handle)\n            return returncode == 0\n        except pywintypes.error:\n            return False\n\n    def _install_pyside(self, python_executable):\n        \"\"\"Install PySide6 python module to cinema4d's python.\"\"\"\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide6 and argument\n            #   \"--ignore-installed\" is to force install module to cinema4d's\n            #   site-packages and make sure it is binary compatible\n            env = dict(os.environ)\n            del env['PYTHONPATH']\n            args = [\n                python_executable,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"--ignore-installed\",\n                \"PySide6\",\n            ]\n            process = subprocess.Popen(\n                args, stdout=subprocess.PIPE, universal_newlines=True,\n                env=env\n            )\n            process.communicate()\n            return process.returncode == 0\n        except PermissionError:\n            self.log.warning(\n                \"Permission denied with command:\"\n                \"\\\"{}\\\".\".format(\" \".join(args))\n            )\n        except OSError as error:\n            self.log.warning(f\"OS error has occurred: \\\"{error}\\\".\")\n        except subprocess.SubprocessError:\n            pass\n\n    def _is_pyside_installed(self, python_executable):\n        \"\"\"Check if PySide6 module is in cinema4d's pip list.\"\"\"\n        args = [python_executable, \"-c\", \"from qtpy import QtWidgets\"]\n        process = subprocess.Popen(args,\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n        _, stderr = process.communicate()\n        stderr = stderr.decode()\n        if stderr:\n            return False\n        return True\n\n    def _windows_require_permissions(self, dirpath):\n        if platform.system().lower() != \"windows\":\n            return False\n\n        try:\n            # Attempt to create a temporary file in the folder\n            temp_file_path = os.path.join(dirpath, uuid.uuid4().hex)\n            with open(temp_file_path, \"w\"):\n                pass\n            os.remove(temp_file_path)  # Clean up temporary file\n            return False\n\n        except PermissionError:\n            return True\n\n        except BaseException as exc:\n            print((\"Failed to determine if root requires permissions.\"\n                   \"Unexpected error: {}\").format(exc))\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_camera.html","title":"create_camera","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_camera.html#client.ayon_cinema4d.plugins.create.create_camera.CreateCamera","title":"<code>CreateCamera</code>","text":"<p>               Bases: <code>Cinema4DCreator</code></p> <p>Single baked camera</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_camera.py</code> <pre><code>class CreateCamera(plugin.Cinema4DCreator):\n    \"\"\"Single baked camera\"\"\"\n\n    identifier = \"io.ayon.creators.cinema4d.camera\"\n    label = \"Camera\"\n    description = __doc__\n    product_type = \"camera\"\n    icon = \"video-camera\"\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n        defs.append(\n            BoolDef(\n                \"bakeToWorldSpace\",\n                label=\"Bake to World Space\",\n                tooltip=(\n                    \"Bake to world space by default, when this is disabled it \"\n                    \" will also include the parent hierarchy in the baked\"\n                    \" results\"\n                ),\n                default=True)\n        )\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_pointcache.html","title":"create_pointcache","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_pointcache.html#client.ayon_cinema4d.plugins.create.create_pointcache.CreatePointcache","title":"<code>CreatePointcache</code>","text":"<p>               Bases: <code>Cinema4DCreator</code></p> <p>Geometry pointcache using Alembic</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_pointcache.py</code> <pre><code>class CreatePointcache(plugin.Cinema4DCreator):\n    \"\"\"Geometry pointcache using Alembic\"\"\"\n\n    identifier = \"io.ayon.creators.cinema4d.pointcache\"\n    label = \"Pointcache\"\n    description = __doc__\n    product_type = \"pointcache\"\n    icon = \"cubes\"\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_redshift_proxy.html","title":"create_redshift_proxy","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_redshift_proxy.html#client.ayon_cinema4d.plugins.create.create_redshift_proxy.CreateRedshiftProxy","title":"<code>CreateRedshiftProxy</code>","text":"<p>               Bases: <code>Cinema4DCreator</code></p> <p>Redshift Proxy</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_redshift_proxy.py</code> <pre><code>class CreateRedshiftProxy(plugin.Cinema4DCreator):\n    \"\"\"Redshift Proxy\"\"\"\n\n    identifier = \"io.ayon.creators.cinema4d.redshiftproxy\"\n    label = \"Redshift Proxy\"\n    product_type = \"redshiftproxy\"\n    description = __doc__\n    icon = \"cubes\"\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_render.html","title":"create_render","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_render.html#client.ayon_cinema4d.plugins.create.create_render.RenderlayerCreator","title":"<code>RenderlayerCreator</code>","text":"<p>               Bases: <code>Cinema4DCreator</code></p> <p>Creator which creates an instance per renderlayer in the workfile.</p> <p>Create and manages render product instancess per Cinema4D Take in workfile. This generates a singleton node in the scene which, if it exists, tells the Creator to collect Cinema4D Takes as individual instances. As such, triggering create doesn't actually create the instance node per layer but only the node which tells the Creator it may now collect an instance per Take.</p> <p>It collects Cinema4D Takes each turning into a render product instance.</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_render.py</code> <pre><code>class RenderlayerCreator(plugin.Cinema4DCreator):\n    \"\"\"Creator which creates an instance per renderlayer in the workfile.\n\n    Create and manages render product instancess per Cinema4D Take in workfile.\n    This generates a singleton node in the scene which, if it exists, tells the\n    Creator to collect Cinema4D Takes as individual instances.\n    As such, triggering create doesn't actually create the instance node per\n    layer but only the node which tells the Creator it may now collect\n    an instance per Take.\n\n    It collects Cinema4D Takes each turning into a render product instance.\n    \"\"\"\n    settings_category = \"cinema4d\"\n\n    identifier = \"io.ayon.creators.cinema4d.render\"\n    label = \"Render\"\n    description = \"Create a render product per Cinema4D Take.\"\n    detailed_description = inspect.cleandoc(__doc__)\n    product_type = \"render\"\n    icon = \"eye\"\n\n    _required_keys = (\"creator_identifier\", \"productName\")\n\n    def _is_marked_workfile_as_render_enabled(self, take_data) -&gt; bool:\n        \"\"\"Return whether the detecting of Takes as render instances is\n        enabled in the current workfile.\n\n        This will be true if at least one Take in the scene has render instance\n        data imprinted onto it.\n        \"\"\"\n        for take in lib.iter_objects(take_data.GetMainTake()):\n            data = self._read_instance_node(take)\n            if all(key in data for key in self._required_keys):\n                return True\n        return False\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        # On creating a first renderlayer instance, we tag the scene so that\n        # from that moment onwards, we collect all takes as renderlayers.\n        # So we put some data somewhere that says, \"takes are now collected\".\n        # self._mark_workfile_as_render_enabled()\n\n        doc: c4d.documents.BaseDocument = c4d.documents.GetActiveDocument()\n        take_data = doc.GetTakeData()\n        if take_data is None:\n            return\n\n        instance_node = None\n        variant_name: str = instance_data.get(\"variant\", \"Main\")\n        print(variant_name)\n        if not self._is_marked_workfile_as_render_enabled(take_data):\n            # If there's already a take with the variant name, we skip creating\n            # a new take but instead just mark the existing take\n            for take in lib.iter_objects(take_data.GetMainTake()):\n                if take.GetName() == variant_name:\n                    # If there's already a take with the variant name,\n                    # we do nothing\n                    instance_node = take\n\n        # Create a new take\n        if instance_node is None:\n            # Add a take so that at least something happens on Create for the\n            # user\n            root = take_data.GetMainTake()\n            instance_node = take_data.AddTake(variant_name, root, None)\n            c4d.EventAdd()\n\n        # Enforce forward compatibility to avoid the instance to default\n        # to the legacy `AVALON_INSTANCE_ID`\n        instance_data[\"id\"] = AYON_INSTANCE_ID\n        # Use the uniqueness of the node in Cinema4D as the instance id\n        instance_data[\"instance_id\"] = str(hash(instance_node))\n        instance = CreatedInstance(\n            product_type=self.product_type,\n            product_name=product_name,\n            data=instance_data,\n            transient_data={\n                \"instance_node\": instance_node,\n                \"take\": instance_node\n            },\n            creator=self,\n        )\n\n        # Store the instance data\n        data = instance.data_to_store()\n        self.imprint_instance_node(instance_node, data)\n\n        self._add_instance_to_context(instance)\n\n        # Then directly refresh with all existing entries\n        self.collect_instances()\n\n    def collect_instances(self):\n        doc: c4d.documents.BaseDocument = c4d.documents.GetActiveDocument()\n        take_data = doc.GetTakeData()\n        if not self._is_marked_workfile_as_render_enabled(take_data):\n            return\n\n        # Each Cinema4D Take is considered a renderlayer\n        for take in lib.iter_objects(take_data.GetMainTake()):\n\n            data = self._read_instance_node(take)\n            if all(key in data for key in self._required_keys):\n                data = self.read_take_overrides(take, data)\n                instance = CreatedInstance.from_existing(data, creator=self)\n            else:\n                take_name: str = take.GetName()\n                variant = self._sanitize_take_variant_name(take_name)\n\n                # No existing scene instance node for this layer. Note that\n                # this instance will not have the `instance_node` data yet\n                # until it's been saved/persisted at least once.\n                folder_entity = self.create_context.get_current_folder_entity()\n                task_entity = self.create_context.get_current_task_entity()\n                instance_data = {\n                    \"folderPath\": folder_entity[\"path\"],\n                    \"task\": task_entity[\"name\"],\n                    \"variant\": variant,\n                }\n\n                # Allow subclass to override data behavior\n                instance_data = self.read_take_overrides(\n                    take, instance_data\n                )\n\n                instance = CreatedInstance(\n                    product_type=self.product_type,\n                    # Defined in `read_take_overrides`\n                    product_name=instance_data[\"productName\"],\n                    data=instance_data,\n                    creator=self\n                )\n\n            instance.transient_data[\"instance_node\"] = take\n            instance.transient_data[\"take\"] = take\n            self._add_instance_to_context(instance)\n\n    def read_take_overrides(\n            self,\n            take: c4d.modules.takesystem.BaseTake,\n            instance_data: dict) -&gt; dict:\n        \"\"\"Overridable read logic to read certain data from the take itself.\n\n        Arguments:\n            take (c4d.modules.takesystem.BaseTake): The render take.\n            instance_data (dict): The instance's data dictionary.\n\n        Returns:\n            dict: The instance's data dictionary with overrides.\n\n        \"\"\"\n        # Override some regular \"read\" logic like active state\n        # retrieved from take active state\n        instance_data[\"active\"] = take.IsChecked()\n\n        project_name = self.create_context.get_current_project_name()\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n        variant = self._sanitize_take_variant_name(take.GetName())\n\n        host_name = self.create_context.host_name\n\n        # Always keep product name in sync with the take name\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n        )\n        instance_data[\"productName\"] = product_name\n        instance_data[\"variant\"] = variant\n\n        return instance_data\n\n    def _sanitize_take_variant_name(self, variant: str) -&gt; str:\n        # Sanitize take variant name (e.g. remove spaces)\n        # because variants and products names are not allowed to have\n        # spaces in them.\n        variant = variant.replace(\" \", \"_\").replace(\"-\", \"_\")\n        return variant\n\n    def imprint_instance_node_data_overrides(self,\n                                             data: dict,\n                                             instance):\n        \"\"\"Persist instance overrides in a custom way.\n\n        Using this you can persist data to the scene that needs to be persisted\n        in an alternate way than regular instance attributes, e.g. a native\n        Cinema4D attribute or alike such as toggling the take active\n        state.\n\n        Make sure to `pop` the data you have already persisted if that data\n        is also read from native Cinema4D node attribute in the scene in\n        `read_instance_node_overrides`. This avoids it still getting written\n        into the `UserData` of the instance node as well.\n\n        Arguments:\n            data (dict): The data available to be 'persisted'.\n            instance (CreatedInstance): The instance operating on.\n\n        Returns:\n            dict: The instance's data that should be persisted into the scene\n                in the regular manner.\n\n        \"\"\"\n        take: c4d.modules.takesystem.BaseTake = instance.transient_data[\"take\"]\n        take.SetChecked(data.pop(\"active\"))\n        take.SetName(data.pop(\"variant\"))\n        return data\n\n    def update_instances(self, update_list):\n        # We only generate the persisting layer data into the scene once\n        # we save with the UI on e.g. validate or publish\n        for instance, _changes in update_list:\n            instance_node = instance.transient_data[\"take\"]\n\n            data = instance.data_to_store()\n            # Allow subclass to override imprinted data behavior\n            # The returned data may be altered (e.g. some data popped) that\n            # custom imprint logic stored elsewhere\n            data = self.imprint_instance_node_data_overrides(data,\n                                                             instance)\n            self.imprint_instance_node(instance_node, data=data)\n        c4d.EventAdd()\n\n    def imprint_instance_node(self, node, data):\n        self._imprint(node, data)\n\n    def remove_instances(self, instances):\n        # Disallow 'deleting the \"Main\" take because it can't be removed\n        for instance in instances:\n            take: c4d.modules.takesystem.BaseTake = (\n                instance.transient_data.get(\"take\")\n            )\n            if not take:\n                continue\n\n            if take.IsMain():\n                # Remove any imprinted instance data, but avoid deleting it\n                # because deleting the main take will crash Cinema4D\n                existing_user_data = take.GetUserDataContainer()\n                instance_data_keys = set(instance.data_to_store().keys())\n                for description_id, base_container in existing_user_data:\n                    key = base_container[c4d.DESC_NAME]\n                    if key in instance_data_keys:\n                        take.RemoveUserData(description_id)\n            else:\n                take.Remove()\n\n            # Remove the collected CreatedInstance to remove from UI directly\n            self._remove_instance_from_context(instance)\n        c4d.EventAdd()\n\n    def get_pre_create_attr_defs(self):\n        return []\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_render.html#client.ayon_cinema4d.plugins.create.create_render.RenderlayerCreator.imprint_instance_node_data_overrides","title":"<code>imprint_instance_node_data_overrides(data, instance)</code>","text":"<p>Persist instance overrides in a custom way.</p> <p>Using this you can persist data to the scene that needs to be persisted in an alternate way than regular instance attributes, e.g. a native Cinema4D attribute or alike such as toggling the take active state.</p> <p>Make sure to <code>pop</code> the data you have already persisted if that data is also read from native Cinema4D node attribute in the scene in <code>read_instance_node_overrides</code>. This avoids it still getting written into the <code>UserData</code> of the instance node as well.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data available to be 'persisted'.</p> required <code>instance</code> <code>CreatedInstance</code> <p>The instance operating on.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The instance's data that should be persisted into the scene in the regular manner.</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_render.py</code> <pre><code>def imprint_instance_node_data_overrides(self,\n                                         data: dict,\n                                         instance):\n    \"\"\"Persist instance overrides in a custom way.\n\n    Using this you can persist data to the scene that needs to be persisted\n    in an alternate way than regular instance attributes, e.g. a native\n    Cinema4D attribute or alike such as toggling the take active\n    state.\n\n    Make sure to `pop` the data you have already persisted if that data\n    is also read from native Cinema4D node attribute in the scene in\n    `read_instance_node_overrides`. This avoids it still getting written\n    into the `UserData` of the instance node as well.\n\n    Arguments:\n        data (dict): The data available to be 'persisted'.\n        instance (CreatedInstance): The instance operating on.\n\n    Returns:\n        dict: The instance's data that should be persisted into the scene\n            in the regular manner.\n\n    \"\"\"\n    take: c4d.modules.takesystem.BaseTake = instance.transient_data[\"take\"]\n    take.SetChecked(data.pop(\"active\"))\n    take.SetName(data.pop(\"variant\"))\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_render.html#client.ayon_cinema4d.plugins.create.create_render.RenderlayerCreator.read_take_overrides","title":"<code>read_take_overrides(take, instance_data)</code>","text":"<p>Overridable read logic to read certain data from the take itself.</p> <p>Parameters:</p> Name Type Description Default <code>take</code> <code>BaseTake</code> <p>The render take.</p> required <code>instance_data</code> <code>dict</code> <p>The instance's data dictionary.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The instance's data dictionary with overrides.</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_render.py</code> <pre><code>def read_take_overrides(\n        self,\n        take: c4d.modules.takesystem.BaseTake,\n        instance_data: dict) -&gt; dict:\n    \"\"\"Overridable read logic to read certain data from the take itself.\n\n    Arguments:\n        take (c4d.modules.takesystem.BaseTake): The render take.\n        instance_data (dict): The instance's data dictionary.\n\n    Returns:\n        dict: The instance's data dictionary with overrides.\n\n    \"\"\"\n    # Override some regular \"read\" logic like active state\n    # retrieved from take active state\n    instance_data[\"active\"] = take.IsChecked()\n\n    project_name = self.create_context.get_current_project_name()\n    folder_entity = self.create_context.get_current_folder_entity()\n    task_entity = self.create_context.get_current_task_entity()\n    variant = self._sanitize_take_variant_name(take.GetName())\n\n    host_name = self.create_context.host_name\n\n    # Always keep product name in sync with the take name\n    product_name = self.get_product_name(\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n    )\n    instance_data[\"productName\"] = product_name\n    instance_data[\"variant\"] = variant\n\n    return instance_data\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_review.html","title":"create_review","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_review.html#client.ayon_cinema4d.plugins.create.create_review.CreateReview","title":"<code>CreateReview</code>","text":"<p>               Bases: <code>Cinema4DCreator</code></p> <p>Viewport render reviewable</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_review.py</code> <pre><code>class CreateReview(plugin.Cinema4DCreator):\n    \"\"\"Viewport render reviewable\"\"\"\n\n    identifier = \"io.ayon.creators.cinema4d.review\"\n    label = \"Review\"\n    description = __doc__\n    product_type = \"review\"\n    icon = \"video-camera\"\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_workfile.html#client.ayon_cinema4d.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> <p>The workfile instance stores its data on the <code>AYON_CONTAINERS</code> collection as custom attributes, because unlike other instances it doesn't have an instance node of its own.</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(AutoCreator):\n    \"\"\"Workfile auto-creator.\n\n    The workfile instance stores its data on the `AYON_CONTAINERS` collection\n    as custom attributes, because unlike other instances it doesn't have an\n    instance node of its own.\n\n    \"\"\"\n    identifier = \"io.ayon.creators.cinema4d.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n    default_variant = \"Main\"\n\n    node_name = \"AYON_workfile\"\n\n    def create(self):\n        \"\"\"Create workfile instances.\"\"\"\n        workfile_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ),\n            None,\n        )\n\n        project_entity = self.create_context.get_current_project_entity()\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n\n        project_name = project_entity[\"name\"]\n        folder_path = folder_entity[\"path\"]\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        existing_folder_path = None\n        if workfile_instance is not None:\n            existing_folder_path = workfile_instance.get(\"folderPath\")\n\n        if not workfile_instance:\n            product_name = self.get_product_name(\n                project_name=project_name,\n                folder_entity=folder_entity,\n                task_entity=task_entity,\n                variant=self.default_variant,\n                host_name=host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": task_name,\n            }\n\n            # Enforce forward compatibility to avoid the instance to default\n            # to the legacy `AVALON_INSTANCE_ID`\n            data[\"id\"] = AYON_INSTANCE_ID\n\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    task_name,\n                    host_name,\n                    workfile_instance,\n                )\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            workfile_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(workfile_instance)\n\n        elif (\n            existing_folder_path != folder_path\n            or workfile_instance[\"task\"] != task_name\n        ):\n            # Update instance context if it's different\n            product_name = self.get_product_name(\n                project_name=project_name,\n                folder_entity=folder_entity,\n                task_entity=task_entity,\n                variant=self.default_variant,\n                host_name=host_name,\n            )\n\n            workfile_instance[\"folderPath\"] = folder_path\n            workfile_instance[\"task\"] = task_name\n            workfile_instance[\"productName\"] = product_name\n\n    def collect_instances(self):\n\n        shared_data = cache_instance_data(self.collection_shared_data)\n        for obj in shared_data[\"cinema4d_cached_instances\"].get(\n                self.identifier, []):\n\n            data = lib.read(obj)\n            data[\"instance_id\"] = str(hash(obj))\n\n            # Add instance\n            created_instance = CreatedInstance.from_existing(data, self)\n\n            # Collect transient data\n            created_instance.transient_data[\"instance_node\"] = obj\n\n            # Add instance to create context\n            self._add_instance_to_context(created_instance)\n\n            # Collect only one\n            break\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n\n            # If it has no node yet, then it's a new workfile instance\n            node = created_inst.transient_data.get(\"instance_node\")\n            if not node:\n                node = plugin.create_selection([], name=self.node_name)\n                plugin.parent_to_ayon_null(node)\n                created_inst.transient_data[\"instance_node\"] = node\n\n            new_data = created_inst.data_to_store()\n\n            # Do not store instance id since it's the node hash\n            new_data.pop(\"instance_id\", None)\n\n            lib.imprint(node, new_data, group=\"AYON\")\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            node = instance.transient_data[\"instance_node\"]\n            node.Remove()\n\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/create/create_workfile.html#client.ayon_cinema4d.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create()</code>","text":"<p>Create workfile instances.</p> Source code in <code>client/ayon_cinema4d/plugins/create/create_workfile.py</code> <pre><code>def create(self):\n    \"\"\"Create workfile instances.\"\"\"\n    workfile_instance = next(\n        (\n            instance for instance in self.create_context.instances\n            if instance.creator_identifier == self.identifier\n        ),\n        None,\n    )\n\n    project_entity = self.create_context.get_current_project_entity()\n    folder_entity = self.create_context.get_current_folder_entity()\n    task_entity = self.create_context.get_current_task_entity()\n\n    project_name = project_entity[\"name\"]\n    folder_path = folder_entity[\"path\"]\n    task_name = task_entity[\"name\"]\n    host_name = self.create_context.host_name\n\n    existing_folder_path = None\n    if workfile_instance is not None:\n        existing_folder_path = workfile_instance.get(\"folderPath\")\n\n    if not workfile_instance:\n        product_name = self.get_product_name(\n            project_name=project_name,\n            folder_entity=folder_entity,\n            task_entity=task_entity,\n            variant=self.default_variant,\n            host_name=host_name,\n        )\n        data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": task_name,\n        }\n\n        # Enforce forward compatibility to avoid the instance to default\n        # to the legacy `AVALON_INSTANCE_ID`\n        data[\"id\"] = AYON_INSTANCE_ID\n\n        data.update(\n            self.get_dynamic_data(\n                project_name,\n                folder_entity,\n                task_entity,\n                task_name,\n                host_name,\n                workfile_instance,\n            )\n        )\n        self.log.info(\"Auto-creating workfile instance...\")\n        workfile_instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self._add_instance_to_context(workfile_instance)\n\n    elif (\n        existing_folder_path != folder_path\n        or workfile_instance[\"task\"] != task_name\n    ):\n        # Update instance context if it's different\n        product_name = self.get_product_name(\n            project_name=project_name,\n            folder_entity=folder_entity,\n            task_entity=task_entity,\n            variant=self.default_variant,\n            host_name=host_name,\n        )\n\n        workfile_instance[\"folderPath\"] = folder_path\n        workfile_instance[\"task\"] = task_name\n        workfile_instance[\"productName\"] = product_name\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/load/actions.html","title":"actions","text":"<p>A module containing generic loader actions that will display in the Loader.</p>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/actions.html#client.ayon_cinema4d.plugins.load.actions.SetFrameRangeLoader","title":"<code>SetFrameRangeLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range excluding pre- and post-handles</p> Source code in <code>client/ayon_cinema4d/plugins/load/actions.py</code> <pre><code>class SetFrameRangeLoader(load.LoaderPlugin):\n    \"\"\"Set frame range excluding pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"pointcache\",\n        \"vdbcache\",\n        \"usd\",\n        \"render\",\n        \"plate\",\n        \"mayaScene\",\n        \"review\"\n    }\n    representations = {\"*\"}\n\n    label = \"Set frame range\"\n    order = 11\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        frame_start = version_attributes.get(\"frameStart\")\n        frame_end = version_attributes.get(\"frameEnd\")\n        if frame_start is None or frame_end is None:\n            print(\n                \"Skipping setting frame range because start or \"\n                \"end frame data is missing..\"\n            )\n            return\n\n        fps = version_attributes[\"fps\"]\n        _set_frame_range(frame_start, frame_end, fps)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/actions.html#client.ayon_cinema4d.plugins.load.actions.SetFrameRangeWithHandlesLoader","title":"<code>SetFrameRangeWithHandlesLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range including pre- and post-handles</p> Source code in <code>client/ayon_cinema4d/plugins/load/actions.py</code> <pre><code>class SetFrameRangeWithHandlesLoader(load.LoaderPlugin):\n    \"\"\"Set frame range including pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"pointcache\",\n        \"vdbcache\",\n        \"usd\",\n        \"render\",\n        \"plate\",\n        \"mayaScene\",\n        \"review\"\n    }\n    representations = {\"*\"}\n\n    label = \"Set frame range (with handles)\"\n    order = 12\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        frame_start = version_attributes.get(\"frameStart\")\n        frame_end = version_attributes.get(\"frameEnd\")\n        if frame_start is None or frame_end is None:\n            print(\n                \"Skipping setting frame range because start or \"\n                \"end frame data is missing..\"\n            )\n            return\n\n        # Include handles\n        frame_start -= version_attributes.get(\"handleStart\", 0)\n        frame_end += version_attributes.get(\"handleEnd\", 0)\n\n        fps = version_attributes[\"fps\"]\n        _set_frame_range(frame_start, frame_end, fps)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_alembic.html","title":"load_alembic","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_alembic.html#client.ayon_cinema4d.plugins.load.load_alembic.AlembicLoader","title":"<code>AlembicLoader</code>","text":"<p>               Bases: <code>Cinema4DLoader</code></p> <p>Load the camera.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_alembic.py</code> <pre><code>class AlembicLoader(plugin.Cinema4DLoader):\n    \"\"\"Load the camera.\"\"\"\n\n    color = \"orange\"\n    product_types = {\"*\"}\n    icon = \"code-fork\"\n    label = \"Load Alembic\"\n    order = -10\n    representations = {\"abc\"}\n\n    def _load_file(self, filepath):\n        \"\"\"Merge a camera from a file.\n\n        Arguments:\n            filepath (str): The full path to the file that contains the camera.\n\n        Returns:\n            c4d.documents.BaseDocument: The loaded document.\n        \"\"\"\n        return c4d.documents.LoadDocument(\n            filepath,\n            c4d.SCENEFILTER_OBJECTS\n            # | c4d.SCENEFILTER_MERGESCENE\n            | c4d.SCENEFILTER_NOUNDO\n            | c4d.SCENEFILTER_IGNOREXREFS\n            | c4d.SCENEFILTER_DONTCORRECTOUTPUTFORMAT,\n        )\n\n    def load(self, context, name=None, namespace=None, options=None):\n        \"\"\"Merge the Alembic into the scene.\"\"\"\n\n        # Merge the alembic, then containerise the generated nodes so we have\n        # access to them on update.\n        filepath = self.filepath_from_context(context)\n\n        doc = lib.active_document()\n\n        name, namespace = self.get_name_and_namespace(\n            context, name, namespace, doc=doc)\n\n        loaded_doc = self._load_file(filepath)\n        nodes = []\n        for obj in loaded_doc.GetObjects():\n            obj.Remove()  # remove from original document\n            doc.InsertObject(obj, checknames=True)\n            nodes.append(obj)\n\n        # TODO: Also containerize all children objects to ensure we keep them\n        #   linked explicitly\n\n        container = pipeline.containerise(\n            name=str(name),\n            namespace=str(namespace),\n            nodes=nodes,\n            context=context,\n            loader=str(self.__class__.__name__),\n        )\n\n        c4d.EventAdd()\n\n        return container\n\n    def update(self, container, context):\n\n        container_node = container[\"node\"]\n        filepath = self.filepath_from_context(context)\n\n        # todo: Add new objects\n        # From the loaded (external) document iterate all its objects, any\n        # new ones insert them into our current document at the right \"place\"\n        # in the hierarchy.\n        # Any already existing ones, do nothing (unless there are specific\n        # updates we want to transfer that it doesn't automatically)\n        # loaded_doc = self._load_file(filepath)\n        # lib.add_objects_to_container(container_node, [camera])\n\n        # todo: Remove or 'tag' removed objects\n        # Any removed ones, keep them dangling in their \"broken\" state. It\n        # looks like Cinema4D is fine with that.\n        # for obj in remove:\n        #     obj.Remove()\n\n        # todo: Update existing objects\n        members = list(lib.get_objects_from_container(container_node))\n        objects = set(members)\n        for obj in members:\n            children = lib.get_all_children(obj)\n            objects.update(children)\n\n        for obj in objects:\n            # Update Alembic Generators\n            if obj.IsInstanceOf(c4d.Oalembicgenerator):\n                obj[c4d.ALEMBIC_PATH] = filepath\n                continue\n\n            # Or if we find a Alembic Morph tag update that instead\n            # This will exist on the object if it was made editable.\n            alembic_morph = obj.GetTag(c4d.Talembicmorphtag)\n            if alembic_morph:\n                alembic_morph[c4d.ALEMBIC_MT_PATH] = filepath\n\n        # Update representation id\n        for i, base_container in container_node.GetUserDataContainer():\n            if base_container[c4d.DESC_NAME] == \"representation\":\n                container_node[i] = context[\"representation\"][\"id\"]\n\n        c4d.EventAdd()\n\n    def remove(self, container):\n        \"\"\"Remove all sub containers\"\"\"\n        container_node = container[\"node\"]\n        for obj in lib.get_objects_from_container(container_node):\n            if obj:\n                obj.Remove()\n        container_node.Remove()\n        c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_alembic.html#client.ayon_cinema4d.plugins.load.load_alembic.AlembicLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Merge the Alembic into the scene.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_alembic.py</code> <pre><code>def load(self, context, name=None, namespace=None, options=None):\n    \"\"\"Merge the Alembic into the scene.\"\"\"\n\n    # Merge the alembic, then containerise the generated nodes so we have\n    # access to them on update.\n    filepath = self.filepath_from_context(context)\n\n    doc = lib.active_document()\n\n    name, namespace = self.get_name_and_namespace(\n        context, name, namespace, doc=doc)\n\n    loaded_doc = self._load_file(filepath)\n    nodes = []\n    for obj in loaded_doc.GetObjects():\n        obj.Remove()  # remove from original document\n        doc.InsertObject(obj, checknames=True)\n        nodes.append(obj)\n\n    # TODO: Also containerize all children objects to ensure we keep them\n    #   linked explicitly\n\n    container = pipeline.containerise(\n        name=str(name),\n        namespace=str(namespace),\n        nodes=nodes,\n        context=context,\n        loader=str(self.__class__.__name__),\n    )\n\n    c4d.EventAdd()\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_alembic.html#client.ayon_cinema4d.plugins.load.load_alembic.AlembicLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove all sub containers</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_alembic.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove all sub containers\"\"\"\n    container_node = container[\"node\"]\n    for obj in lib.get_objects_from_container(container_node):\n        if obj:\n            obj.Remove()\n    container_node.Remove()\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_camera.html","title":"load_camera","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_camera.html#client.ayon_cinema4d.plugins.load.load_camera.CameraLoader","title":"<code>CameraLoader</code>","text":"<p>               Bases: <code>Cinema4DLoader</code></p> <p>Load the camera.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_camera.py</code> <pre><code>class CameraLoader(plugin.Cinema4DLoader):\n    \"\"\"Load the camera.\"\"\"\n\n    color = \"orange\"\n    product_types = {\"camera\"}\n    representations = {\"abc\"}\n    icon = \"file-video-o\"\n    label = \"Load Camera\"\n    order = -11\n\n    def _merge_camera(self, filepath, doc=None):\n        \"\"\"Merge a camera from a file.\n\n        Arguments:\n            filepath (str): The full path to the file that contains the camera.\n            doc (optional c4d.documents.BaseDocument): The document to put the\n                camera in. By default this will be the active document.\n\n        Returns:\n            c4d.BaseList2D: The merge camera object\n        \"\"\"\n\n        doc = doc or lib.active_document()\n        camera_doc = c4d.documents.LoadDocument(\n            filepath,\n            c4d.SCENEFILTER_OBJECTS\n            # | c4d.SCENEFILTER_MERGESCENE\n            | c4d.SCENEFILTER_NOUNDO\n            | c4d.SCENEFILTER_IGNOREXREFS\n            | c4d.SCENEFILTER_DONTCORRECTOUTPUTFORMAT,\n        )\n\n        # TODO: We should include the parent hierarchy of the loaded camera\n        #  to ensure the full correct transformations? As such, maybe we should\n        #  merge the full camera - and only make editable the camera objects\n        for obj in lib.iter_objects(camera_doc.GetFirstObject()):\n            # Get internal camera data from the Alembic Generator\n            data = {\"res\": None}\n            if not obj.Message(c4d.MSG_GETREALCAMERADATA, data):\n                continue\n\n            if data[\"res\"] is not None:\n                camera_alembic = obj\n                break\n        else:\n            raise RuntimeError(f\"No camera found in {filepath}\")\n\n        # The camera should be the only object in the file\n        result = c4d.utils.SendModelingCommand(\n            command=c4d.MCOMMAND_MAKEEDITABLE,\n            list=[camera_alembic],\n            doc=doc,\n        )\n        assert result, \"Making the camera editable failed.\"\n        camera = result[0]\n        assert camera.GetTypeName() == \"Camera\", \"No camera found in: {}\".format(\n            filepath\n        )\n\n        self.log.info(\"Loaded camera '%s' from %s\", camera.GetName(), filepath)\n\n        return camera\n\n    def _protect_camera(self, camera):\n        \"\"\"Add a protection tag to the camera.\n\n        Arguments:\n            camera (c4d.CameraObject): The camera to protect.\n        \"\"\"\n\n        protection_tag = c4d.BaseTag(c4d.Tprotection)\n        camera.InsertTag(protection_tag)\n        self.log.debug(\"Added a protection tag to camera '%s'\", camera.GetName())\n\n    def load(self, context, name=None, namespace=None, options=None):\n        \"\"\"Load the camera.\"\"\"\n\n        doc = lib.active_document()\n        name, namespace = self.get_name_and_namespace(\n            context, name, namespace, doc)\n        basename = f\"{namespace}_{name}\"\n\n        filepath = self.filepath_from_context(context)\n        camera = self._merge_camera(filepath, doc)\n\n        doc.InsertObject(camera)\n        camera.SetName(str(basename))\n\n        # Set the camera as the active camera\n        for basedraw in (doc.GetActiveBaseDraw(), doc.GetRenderBaseDraw()):\n            basedraw.SetSceneCamera(camera)\n\n        self._protect_camera(camera)\n\n        container = pipeline.containerise(\n            name=str(name),\n            namespace=str(namespace),\n            nodes=[camera],\n            context=context,\n            loader=str(self.__class__.__name__),\n        )\n\n        c4d.EventAdd()\n\n        return container\n\n    def update(self, container, context):\n        doc = lib.active_document()\n        container_node = container[\"node\"]\n        filepath = self.filepath_from_context(context)\n\n        camera_name = None\n        camera_tags = None\n        # There should be only 1 camera node here, remove it\n        for obj in lib.get_objects_from_container(container_node):\n            if obj.GetTypeName() == \"Camera\":\n                camera_name = obj.GetName()\n                camera_tags = obj.GetTags()\n            obj.Remove()\n\n        # Add new camera\n        camera = self._merge_camera(filepath, doc=doc)\n        doc.InsertObject(camera)\n\n        if camera_name:\n            camera.SetName(str(camera_name))\n        if camera_tags:\n            for tag in camera_tags:\n                camera.InsertTag(tag)\n\n        # Set the camera as the active camera\n        for basedraw in (doc.GetActiveBaseDraw(), doc.GetRenderBaseDraw()):\n            basedraw.SetSceneCamera(camera)\n\n        self._protect_camera(camera)\n\n        lib.add_objects_to_container(container_node, [camera])\n\n        # Update representation id\n        for i, base_container in container_node.GetUserDataContainer():\n            if base_container[c4d.DESC_NAME] == \"representation\":\n                container_node[i] = context[\"representation\"][\"id\"]\n\n        c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_camera.html#client.ayon_cinema4d.plugins.load.load_camera.CameraLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Load the camera.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_camera.py</code> <pre><code>def load(self, context, name=None, namespace=None, options=None):\n    \"\"\"Load the camera.\"\"\"\n\n    doc = lib.active_document()\n    name, namespace = self.get_name_and_namespace(\n        context, name, namespace, doc)\n    basename = f\"{namespace}_{name}\"\n\n    filepath = self.filepath_from_context(context)\n    camera = self._merge_camera(filepath, doc)\n\n    doc.InsertObject(camera)\n    camera.SetName(str(basename))\n\n    # Set the camera as the active camera\n    for basedraw in (doc.GetActiveBaseDraw(), doc.GetRenderBaseDraw()):\n        basedraw.SetSceneCamera(camera)\n\n    self._protect_camera(camera)\n\n    container = pipeline.containerise(\n        name=str(name),\n        namespace=str(namespace),\n        nodes=[camera],\n        context=context,\n        loader=str(self.__class__.__name__),\n    )\n\n    c4d.EventAdd()\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_redshiftproxy.html","title":"load_redshiftproxy","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_redshiftproxy.html#client.ayon_cinema4d.plugins.load.load_redshiftproxy.RedshiftProxyLoader","title":"<code>RedshiftProxyLoader</code>","text":"<p>               Bases: <code>Cinema4DSingleObjLoader</code></p> <p>Load Redshift Proxy.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_redshiftproxy.py</code> <pre><code>class RedshiftProxyLoader(plugin.Cinema4DSingleObjLoader):\n    \"\"\"Load Redshift Proxy.\"\"\"\n\n    color = \"orange\"\n    product_types = {\"*\"}\n    icon = \"code-fork\"\n    label = \"Load Redshift Proxy\"\n    order = -10\n    representations = {\"rs\"}\n\n    # TODO: Automatically enable 'animation' on the redshift proxy with\n    #  the correct frame start / frame end and offsets so it plays at the\n    #  same frames as the source scene.\n\n    @property\n    def _node_type_id(self):\n        return 1038649  # Redshift Proxy ID\n\n    @property\n    def _filepath_attribute(self):\n        return c4d.REDSHIFT_PROXY_FILE, c4d.REDSHIFT_FILE_PATH\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_vdb_to_redshift.html","title":"load_vdb_to_redshift","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_vdb_to_redshift.html#client.ayon_cinema4d.plugins.load.load_vdb_to_redshift.LoadVDBToRedshift","title":"<code>LoadVDBToRedshift</code>","text":"<p>               Bases: <code>Cinema4DSingleObjLoader</code></p> <p>Load VDB to Redshift Volume.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_vdb_to_redshift.py</code> <pre><code>class LoadVDBToRedshift(plugin.Cinema4DSingleObjLoader):\n    \"\"\"Load VDB to Redshift Volume.\"\"\"\n\n    color = \"orange\"\n    product_types = {\"*\"}\n    icon = \"cloud\"\n    label = \"Load VDB to Redshift\"\n    order = -10\n    representations = {\"vdb\"}\n\n    # TODO: Automatically set Animation to \"Frame\" when loading a vdb sequence\n    #  and correctly set the start frame, end frame and offsets\n\n    @property\n    def _node_type_id(self) -&gt; int:\n        return 1038655  # Redshift Volume ID\n\n    @property\n    def _filepath_attribute(self):\n        return c4d.REDSHIFT_VOLUME_FILE, c4d.REDSHIFT_FILE_PATH\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_volume.html","title":"load_volume","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_volume.html#client.ayon_cinema4d.plugins.load.load_volume.LoadVolume","title":"<code>LoadVolume</code>","text":"<p>               Bases: <code>Cinema4DSingleObjLoader</code></p> <p>Load VDB to Volume Loader.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_volume.py</code> <pre><code>class LoadVolume(plugin.Cinema4DSingleObjLoader):\n    \"\"\"Load VDB to Volume Loader.\"\"\"\n\n    color = \"orange\"\n    product_types = {\"*\"}\n    icon = \"cloud\"\n    label = \"Load VDB to Volume Loader\"\n    order = -10\n    representations = {\"vdb\"}\n\n    @property\n    def _node_type_id(self) -&gt; int:\n        return 1039866  # Volume Loader ID\n\n    @property\n    def _filepath_attribute(self):\n        return c4d.ID_VOLUMESEQUENCE_PATH\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_xref.html","title":"load_xref","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_xref.html#client.ayon_cinema4d.plugins.load.load_xref.XRefLoader","title":"<code>XRefLoader</code>","text":"<p>               Bases: <code>Cinema4DLoader</code></p> <p>Load a file as XRef.</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_xref.py</code> <pre><code>class XRefLoader(plugin.Cinema4DLoader):\n    \"\"\"Load a file as XRef.\"\"\"\n\n    label = \"Load XRef\"\n\n    product_types = {\"*\"}\n    representations = {\"c4d\", \"abc\", \"fbx\"}\n    icon = \"code-fork\"\n    color = \"orange\"\n    order = -8\n\n    def load(self, context, name=None, namespace=None, options=None):\n        \"\"\"Load the asset as XRef.\n\n        Todo:\n            - Find out how to set the path to non-relative.\n            - Find out how to set the namespace separator.\n        \"\"\"\n        filepath = self.filepath_from_context(context)\n        doc = lib.active_document()\n        name, namespace = self.get_name_and_namespace(\n            context, name, namespace, doc)\n        basename = f\"{namespace}_{name}\"\n\n        xref = c4d.BaseList2D(c4d.Oxref)\n        xref.SetName(basename)\n        doc.InsertObject(xref)\n        xref.SetParameter(\n            c4d.ID_CA_XREF_FILE,\n            filepath,\n            c4d.DESCFLAGS_SET_USERINTERACTION\n        )\n        xref.SetParameter(\n            c4d.ID_CA_XREF_NAMESPACE,\n            str(namespace),\n            c4d.DESCFLAGS_SET_USERINTERACTION\n        )\n        c4d.EventAdd()\n        # c4d.ID_CA_XREF_FILE       # filepath\n        # c4d.ID_CA_XREF_NAMESPACE  # namespace\n        # c4d.ID_CA_XREF_LOADED     # loaded checkbox\n        # c4d.ID_CA_XREF_RELATIVE   # Relative to project\n\n        container = pipeline.containerise(\n            name=str(name),\n            namespace=str(namespace),\n            nodes=[xref],\n            context=context,\n            loader=str(self.__class__.__name__),\n        )\n\n        return container\n\n    def update(self, container, context):\n        filepath = self.filepath_from_context(context)\n        container_node = container[\"node\"]\n\n        # There should be only 1 xref node\n        for xref in lib.get_objects_from_container(container_node):\n            if xref.GetTypeName() == \"XRef\":\n                # This requires `c4d.DESCFLAGS_SET_USERINTERACTION`\n                # which will unfortunately prompt the user to confirm it.\n                # There is no other way, see:\n                # https://developers.maxon.net/forum/topic/15728/update-xref-filepath-without-user-interaction  # noqa: E402\n                xref.SetParameter(\n                    c4d.ID_CA_XREF_FILE,\n                    filepath,\n                    c4d.DESCFLAGS_SET_USERINTERACTION,\n                )\n\n        # Update the representation id\n        for i, base_container in container_node.GetUserDataContainer():\n            if base_container[c4d.DESC_NAME] == \"representation\":\n                container_node[i] = context[\"representation\"][\"id\"]\n                break\n\n        c4d.EventAdd()\n\n    def remove(self, container):\n        \"\"\"Remove all sub containers\"\"\"\n        container_node = container[\"node\"]\n        for obj in lib.get_objects_from_container(container_node):\n            obj.Remove()\n        container_node.Remove()\n        c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_xref.html#client.ayon_cinema4d.plugins.load.load_xref.XRefLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Load the asset as XRef.</p> Todo <ul> <li>Find out how to set the path to non-relative.</li> <li>Find out how to set the namespace separator.</li> </ul> Source code in <code>client/ayon_cinema4d/plugins/load/load_xref.py</code> <pre><code>def load(self, context, name=None, namespace=None, options=None):\n    \"\"\"Load the asset as XRef.\n\n    Todo:\n        - Find out how to set the path to non-relative.\n        - Find out how to set the namespace separator.\n    \"\"\"\n    filepath = self.filepath_from_context(context)\n    doc = lib.active_document()\n    name, namespace = self.get_name_and_namespace(\n        context, name, namespace, doc)\n    basename = f\"{namespace}_{name}\"\n\n    xref = c4d.BaseList2D(c4d.Oxref)\n    xref.SetName(basename)\n    doc.InsertObject(xref)\n    xref.SetParameter(\n        c4d.ID_CA_XREF_FILE,\n        filepath,\n        c4d.DESCFLAGS_SET_USERINTERACTION\n    )\n    xref.SetParameter(\n        c4d.ID_CA_XREF_NAMESPACE,\n        str(namespace),\n        c4d.DESCFLAGS_SET_USERINTERACTION\n    )\n    c4d.EventAdd()\n    # c4d.ID_CA_XREF_FILE       # filepath\n    # c4d.ID_CA_XREF_NAMESPACE  # namespace\n    # c4d.ID_CA_XREF_LOADED     # loaded checkbox\n    # c4d.ID_CA_XREF_RELATIVE   # Relative to project\n\n    container = pipeline.containerise(\n        name=str(name),\n        namespace=str(namespace),\n        nodes=[xref],\n        context=context,\n        loader=str(self.__class__.__name__),\n    )\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/load/load_xref.html#client.ayon_cinema4d.plugins.load.load_xref.XRefLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove all sub containers</p> Source code in <code>client/ayon_cinema4d/plugins/load/load_xref.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove all sub containers\"\"\"\n    container_node = container[\"node\"]\n    for obj in lib.get_objects_from_container(container_node):\n        obj.Remove()\n    container_node.Remove()\n    c4d.EventAdd()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_current_document.html","title":"collect_current_document","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_current_document.html#client.ayon_cinema4d.plugins.publish.collect_current_document.CollectCinema4DActiveDocument","title":"<code>CollectCinema4DActiveDocument</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the c4d.documents.GetActiveDocument() into context</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_current_document.py</code> <pre><code>class CollectCinema4DActiveDocument(pyblish.api.ContextPlugin):\n    \"\"\"Inject the c4d.documents.GetActiveDocument() into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Cinema4D Active Docuemnt\"\n    hosts = ['cinema4d']\n\n    def process(self, context):\n        context.data['doc'] = c4d.documents.GetActiveDocument()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_current_file.html#client.ayon_cinema4d.plugins.publish.collect_current_file.CollectCinema4DCurrentFile","title":"<code>CollectCinema4DCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCinema4DCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Cinema4D Current File\"\n    hosts = [\"cinema4d\"]\n\n    def process(self, context):\n        \"\"\"Inject the current working file\"\"\"\n\n        current_file = api.current_file()\n        context.data['currentFile'] = current_file\n        if not current_file:\n            self.log.warning(\n                \"Current file is not saved. Save the file before continuing.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_current_file.html#client.ayon_cinema4d.plugins.publish.collect_current_file.CollectCinema4DCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file\"\"\"\n\n    current_file = api.current_file()\n    context.data['currentFile'] = current_file\n    if not current_file:\n        self.log.warning(\n            \"Current file is not saved. Save the file before continuing.\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_instances.html","title":"collect_instances","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_instances.html#client.ayon_cinema4d.plugins.publish.collect_instances.CollectInstances","title":"<code>CollectInstances</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_instances.py</code> <pre><code>class CollectInstances(pyblish.api.InstancePlugin):\n    label = \"Collect Instances\"\n    order = pyblish.api.CollectorOrder - 0.4\n    hosts = [\"cinema4d\"]\n\n    def process(self, instance):\n\n        if instance.data.get(\"productType\") == \"render\":\n            return\n\n        self.log.debug(f\"Collecting members for {instance}\")\n\n        # Add the creator attributes to instance.data\n        self.creator_attributes_to_instance_data(instance)\n\n        # Collect members from the instance node\n        instance_node = instance.data[\"transientData\"][\"instance_node\"]\n        members = list(lib.get_objects_from_container(instance_node))\n\n        members_hierarchy = set(members)\n        if instance.data.get(\"includeParentHierarchy\", True):\n            parents = self.get_all_parents(members)\n            members_hierarchy.update(parents)\n\n        # Store members hierarchy\n        instance[:] = list(members_hierarchy)\n\n        # Store the exact members of the object set\n        instance.data[\"setMembers\"] = members\n\n        # Define nice label\n        name = instance_node.GetName()  # use short name\n        label = \"{0} ({1})\".format(name, instance.data[\"folderPath\"])\n\n        # Set frame start handle and frame end handle if frame ranges are\n        # available\n        if \"frameStart\" in instance.data and \"frameEnd\" in instance.data:\n            # Enforce existence if handles\n            instance.data.setdefault(\"handleStart\", 0)\n            instance.data.setdefault(\"handleEnd\", 0)\n\n            # Compute frame start handle and end start handle\n            frame_start_handle = (\n                instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n            )\n            frame_end_handle = (\n                instance.data[\"frameEnd\"] - instance.data[\"handleEnd\"]\n            )\n            instance.data[\"frameStartHandle\"] = frame_start_handle\n            instance.data[\"frameEndHandle\"] = frame_end_handle\n\n            # Include frame range in label\n            label += \"  [{0}-{1}]\".format(int(frame_start_handle),\n                                          int(frame_end_handle))\n\n        instance.data[\"label\"] = label\n\n    def get_all_parents(self, nodes):\n        \"\"\"Get all parents by using string operations (optimization)\n\n        Args:\n            nodes (list): the nodes which are found in the objectSet\n\n        Returns:\n            list\n        \"\"\"\n\n        parents = []\n        for node in nodes:\n            parent = node.GetUp()\n            while parent:\n                parents.append(parent)\n                parent = parent.GetUp()\n\n        return parents\n\n    def creator_attributes_to_instance_data(self, instance):\n        creator_attributes = instance.data.get(\"creator_attributes\", {})\n        if not creator_attributes:\n            return\n\n        for key, value in creator_attributes.items():\n            if key in instance.data:\n                continue\n\n            instance.data[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_instances.html#client.ayon_cinema4d.plugins.publish.collect_instances.CollectInstances.get_all_parents","title":"<code>get_all_parents(nodes)</code>","text":"<p>Get all parents by using string operations (optimization)</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>the nodes which are found in the objectSet</p> required <p>Returns:</p> Type Description <p>list</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_instances.py</code> <pre><code>def get_all_parents(self, nodes):\n    \"\"\"Get all parents by using string operations (optimization)\n\n    Args:\n        nodes (list): the nodes which are found in the objectSet\n\n    Returns:\n        list\n    \"\"\"\n\n    parents = []\n    for node in nodes:\n        parent = node.GetUp()\n        while parent:\n            parents.append(parent)\n            parent = parent.GetUp()\n\n    return parents\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_render.html","title":"collect_render","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_render.html#client.ayon_cinema4d.plugins.publish.collect_render.CollectCinema4DRender","title":"<code>CollectCinema4DRender</code>","text":"<p>               Bases: <code>AbstractCollectRender</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Each active render instance represents a <code>Take</code> inside Cinema4D. For this take we will get its render settings and will compute the applicable frame range and expected output files as well.</p> <p>Each take in Cinema4D can have its own \"Render Settings\" overrides. As such each take may have its own \"Render Data\" and \"Video Post\" as a result it can have different frame ranges, renderer, etc. and also different output filepath settings. See: https://developers.maxon.net/docs/Cinema4DCPPSDK/page_overview_takesystem.html  # noqa</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_render.py</code> <pre><code>class CollectCinema4DRender(\n    publish.AbstractCollectRender,\n    publish.ColormanagedPyblishPluginMixin\n):\n    \"\"\"\n    Each active render instance represents a `Take` inside Cinema4D. For this\n    take we will get its render settings and will compute the applicable\n    frame range and expected output files as well.\n\n    Each take in Cinema4D can have its own \"Render Settings\" overrides.\n    As such each take may have its own \"Render Data\" and \"Video Post\"\n    as a result it can have different frame ranges, renderer, etc.\n    and also different output filepath settings.\n    See: https://developers.maxon.net/docs/Cinema4DCPPSDK/page_overview_takesystem.html  # noqa\n    \"\"\"\n    order = pyblish.api.CollectorOrder + 0.1\n    label = \"Collect Render\"\n    hosts = [\"cinema4d\"]\n    families = [\"render\"]\n\n    def get_instances(self, context):\n        current_file = context.data[\"currentFile\"]\n        version = context.data.get(\"version\")\n        project_entity = context.data[\"projectEntity\"]\n        doc: c4d.documents.BaseDocument = context.data[\"doc\"]\n        take_data = doc.GetTakeData()\n\n        scene_ocio_config = lib_renderproducts.get_scene_ocio_config(doc)\n        self.log.debug(f\"Scene OCIO Config: '{scene_ocio_config['config']}'\")\n        self.log.debug(f\"Scene OCIO Display: '{scene_ocio_config['display']}'\")\n        self.log.debug(f\"Scene OCIO View: '{scene_ocio_config['view']}'\")\n        self.log.debug(\n            f\"Scene OCIO Colorspace: '{scene_ocio_config['colorspace']}'\"\n        )\n\n        instances: list[Cinema4DRenderInstance] = []\n        for inst in context:\n            if not inst.data.get(\"active\", True):\n                continue\n\n            product_type = inst.data[\"productType\"]\n            if product_type != \"render\":\n                continue\n\n            # Get take from instance\n            take: c4d.modules.takesystem.BaseTake = (\n                inst.data[\"transientData\"][\"take\"]\n            )\n            render_data, base_take = take.GetEffectiveRenderData(take_data)\n\n            # Get take name, resolution, frame range\n            fps: float = doc.GetFps()\n            resolution_width: int = int(render_data[c4d.RDATA_XRES])\n            resolution_height: int = int(render_data[c4d.RDATA_YRES])\n            pixel_aspect: float = float(render_data[c4d.RDATA_PIXELASPECT])\n            frame_start: int = int(\n                render_data[c4d.RDATA_FRAMEFROM].GetFrame(fps)\n            )\n            frame_end: int = int(\n                render_data[c4d.RDATA_FRAMETO].GetFrame(fps)\n            )\n            step: int = int(render_data[c4d.RDATA_FRAMESTEP])\n\n            instance_families = inst.data.get(\"families\", [])\n            product_name = inst.data[\"productName\"]\n            instance = Cinema4DRenderInstance(\n                productType=product_type,\n                family=product_type,\n                families=instance_families,\n                version=version,\n                time=\"\",\n                source=current_file,\n                label=inst.data[\"label\"],\n                productName=product_name,\n                folderPath=inst.data[\"folderPath\"],\n                task=inst.data[\"task\"],\n                attachTo=[],\n                setMembers=\"\",\n                publish=True,\n                name=product_name,\n                resolutionWidth=resolution_width,\n                resolutionHeight=resolution_height,\n                pixelAspect=pixel_aspect,\n                review=\"review\" in instance_families,\n                frameStart=frame_start,\n                frameEnd=frame_end,\n                # TODO: define sensible way to set \"handles\" for a take\n                handleStart=0,\n                handleEnd=0,\n                frameStartHandle=frame_start,\n                frameEndHandle=frame_end,\n                frameStep=step,\n                fps=fps,\n                publish_attributes=inst.data.get(\"publish_attributes\", {}),\n                # The source instance this render instance replaces\n                source_instance=inst,\n\n                renderProducts=lib_renderproducts.ARenderProduct(\n                    frame_start=frame_start,\n                    frame_end=frame_end\n                ),\n\n                # Required for submit publish job\n                renderData=render_data,\n                colorspaceConfig=scene_ocio_config[\"config\"],\n                colorspaceDisplay=scene_ocio_config[\"display\"],\n                colorspaceView=scene_ocio_config[\"view\"],\n                sceneRenderColorspace=scene_ocio_config[\"colorspace\"],\n            )\n\n            instance.farm = True\n            instance.projectEntity = project_entity\n            instance.deadline = inst.data.get(\"deadline\")\n            instances.append(instance)\n\n        return instances\n\n    def get_expected_files(self, render_instance: Cinema4DRenderInstance):\n        \"\"\"Return expected output files from the render\"\"\"\n        # TODO: Support built-in standard, physical and viewport renderers\n        # TODO: Relative paths may need to be made absolute because otherwise\n        #  those paths will become relative to the PUBLISHED scenefile instead\n        #  of the WORKFILE?\n\n        instance: pyblish.api.Instance = render_instance.source_instance\n        render_data: c4d.documents.RenderData = render_instance.renderData\n        doc = render_data.GetDocument()\n\n        # From the Take and Render Data we find the correct output path,\n        # whether it is multipass and what AOVs are enabled for the renderer.\n        # Each output file is considered to be a \"Render Product\" similar to\n        # USD terminology.\n        take: c4d.modules.takesystem.BaseTake = (\n            instance.data[\"transientData\"][\"take\"]\n        )\n\n        # Debug log what take we're processing, etc.\n        self.log.debug(f\"Take: {take.GetName()}\")\n        self.log.debug(f\"  Render Settings: {render_data.GetName()}\")\n        self.log.debug(\n            \"  Frame range: \"\n            f\"{render_instance.frameStartHandle}-\"\n            f\"{render_instance.frameEndHandle}x\"\n            f\"{render_instance.frameStep}\"\n        )\n        self.log.debug(\n            f\"  Resolution:  \"\n            f\"{render_instance.resolutionWidth}x\"\n            f\"{render_instance.resolutionHeight}\"\n        )\n\n        # Debug log video posts\n        video_posts: list[c4d.documents.BaseVideoPost] = lib.get_siblings(\n            render_data.GetFirstVideoPost()\n        )\n        video_posts_names = \", \".join(vp.GetName() for vp in video_posts)\n        self.log.debug(f\"  Video posts: {video_posts_names}\")\n\n        name_format: int = render_data[c4d.RDATA_NAMEFORMAT]\n\n        def files_resolver(\n            token_path: str,\n            layer_name: str = \"$userpass\",\n            layer_type_name: str = \"$pass\",\n            file_format: int = render_data[c4d.RDATA_MULTIPASS_SAVEFORMAT],\n        ) -&gt; list[str]:\n            \"\"\"Return filepaths for all frames with given token path and\n            layer names.\"\"\"\n            files: list[str] = []\n            token_path = self._abspath(doc, token_path)\n            for frame in range(\n                render_instance.frameStartHandle,\n                render_instance.frameEndHandle + 1,\n            ):\n                resolved_path = lib_renderproducts.resolve_filepath(\n                    token_path,\n                    doc=doc,\n                    render_data=render_data,\n                    layer_name=layer_name,\n                    layer_type_name=layer_type_name,\n                    take=take,\n                    frame=frame,\n                )\n                resolved_path = lib_renderproducts.apply_name_format(\n                    resolved_path,\n                    name_format=name_format,\n                    file_format=file_format,\n                    frame=frame\n                )\n                files.append(resolved_path)\n            return files\n\n        # Get take render data AOVs\n        products: dict[str, list[str]] = {}\n\n        # Regular image\n        save_image: bool = render_data[c4d.RDATA_SAVEIMAGE]\n        if save_image:\n            token_path: str = render_data[c4d.RDATA_PATH]\n            products[\"\"] = files_resolver(\n                token_path,\n                file_format=render_data[c4d.RDATA_FORMAT]\n            )\n\n        # Multi-Pass image\n        save_multipass_image: bool = render_data[c4d.RDATA_MULTIPASS_SAVEIMAGE]\n        if save_multipass_image:\n            products.update(\n                self._collect_multipass(\n                    render_data,\n                    files_resolver\n                )\n            )\n\n        # Set output dir from the beauty output because it is required for\n        # publish metadata to be written out and the publish job submission\n        # to succeed\n        if products:\n            first_product_file: str = next(iter(products.values()))[0]\n            render_instance.outputDir = os.path.dirname(first_product_file)\n            self.log.debug(\n                f\"Collected output directory: {render_instance.outputDir}\"\n            )\n        else:\n            render_instance.outputDir = None\n            self.log.warning(\"No render outputs collected; outputDir set to None.\")\n\n        # Debug log all collected sequences\n        for aov_name, aov_files in products.items():\n            if aov_name == \"\":\n                aov_name = \"&lt;Beauty&gt;\"\n\n            collections, remainder = clique.assemble(aov_files)\n            file_labels = remainder + list(\n                str(collection) for collection in collections\n            )\n            self.log.debug(f\"  {aov_name} files: {', '.join(file_labels)}\")\n\n        # Assume that for all render products we have the same colorspace\n        # so for now we will apply the scene render colorspace to all products\n        # This is used by the Submit Publish Job plug-in to set the colorspace\n        # for each instance\n        for aov_name, files in products.items():\n            render_instance.renderProducts.layer_data.products.append(\n                lib_renderproducts.RenderProduct(\n                    productName=aov_name,\n                    colorspace=render_instance.sceneRenderColorspace,\n                )\n            )\n\n        return [products]\n\n    def _collect_multipass(\n        self,\n        render_data,\n        files_resolver\n    ) -&gt; dict[str, list[str]]:\n        multipass_token_path: str = render_data[c4d.RDATA_MULTIPASS_FILENAME]\n        self.log.debug(\n            f\"Collected Multi-Pass Filepath: {multipass_token_path}\"\n        )\n\n        # If Multi-Layer File is enabled then the renderer will write into\n        # a single file for all AOVs, except in some cases a renderer may write\n        # into a separate file certain AOVs, like a Cryptomatte.\n        # '$pass' becomes `unresolved` if multi-layer file is enabled but the\n        # token is present in the output path.\n        multipass_enabled: bool = bool(render_data[c4d.RDATA_MULTIPASS_ENABLE])\n        multilayer_file: bool = render_data[c4d.RDATA_MULTIPASS_SAVEONEFILE]\n\n        if multipass_enabled and multilayer_file:\n            # TODO: Check if Cryptomatte is still forced to be written out\n            #   in this scenario as a separate file.\n            # Single file\n            return {\"\": files_resolver(multipass_token_path)}\n\n        # Support Redshift AOVs\n        renderer: int = render_data[c4d.RDATA_RENDERENGINE]\n        if renderer == redshift.VPrsrenderer:\n            self.log.debug(\"Renderer is Redshift.\")\n            redshift_vp = lib_renderproducts.find_video_post(\n                render_data,\n                lib_renderproducts.REDSHIFT_RENDER_ENGINE_ID\n            )\n            if redshift_vp:\n                return self._collect_redshift_aovs(\n                    redshift_vp,\n                    files_resolver_fn=files_resolver,\n                    multipass_token_path=multipass_token_path\n                )\n\n        return {}\n\n    def _collect_redshift_aovs(\n        self,\n        redshift_vp: c4d.documents.BaseVideoPost,\n        files_resolver_fn,\n        multipass_token_path: str\n    ) -&gt; dict[str, list[str]]:\n        \"\"\"Collect all Redshift AOVs output filepaths by AOV name.\"\"\"\n        products: dict[str, list[str]] = {}\n\n        # If Global AOV mode is set to disabled, collect no AOV data\n        aov_disabled: int = c4d.REDSHIFT_RENDERER_AOV_GLOBAL_MODE_DISABLE\n        if redshift_vp[c4d.REDSHIFT_RENDERER_AOV_GLOBAL_MODE] == aov_disabled:\n            self.log.debug(\"Redshift Global AOV mode is disabled.\")\n            return products\n\n        self.log.debug(\"Collecting Redshift AOVs...\")\n        layer_index: int = 0\n        for aov in lib_renderproducts.iter_redshift_aovs(redshift_vp):\n            self.log.debug(f\"  {aov}\")\n            if not aov.enabled:\n                continue\n\n            # AOV has no enabled outputs\n            if not aov.multipass_enabled and not aov.direct_enabled:\n                continue\n\n            layer_index += 1\n            aov_name: str = aov.name or aov.effective_name\n\n            # Get filepath without extension and the frame suffix that\n            # Redshift already includes in the effective path\n            if aov.direct_enabled:\n                # TODO: File effective path does not work with e.g. Light\n                #  Groups because it will always return the direct AOV path\n                #  from C4D instead of our 'copied' aovs\n                filepath = os.path.splitext(aov.file_effective_path)[0]\n                filepath = filepath.rstrip(\"0123456789\")\n                files = files_resolver_fn(filepath)\n            else:\n                # Make a copy because we may alter it for AOV suffix\n                multipass_token_path_aov = multipass_token_path\n\n                # For whatever reason the Depth AOV comes out as \"$userpass\"\n                # instead of the effective name \"Z\".\n                layer_name: str = aov.name or aov.effective_name\n                if not aov.name and aov.effective_name == \"Z\":\n                    layer_name = \"$userpass\"\n\n                # Add layer name suffix\n                add_automated_layer_name: bool = (\n                    \"$pass\" not in multipass_token_path_aov\n                    and \"$userpass\" not in multipass_token_path_aov\n                )\n                if add_automated_layer_name:\n                    filename_suffix = f\"_{aov_name.lower()}_{layer_index}\"\n                    multipass_token_path_aov += filename_suffix\n\n                # Format the filepath based on the render data's token\n                # path\n                files = files_resolver_fn(\n                    multipass_token_path_aov,\n                    layer_name=layer_name,\n                    layer_type_name=aov.effective_name,\n                )\n\n            products[aov_name] = files\n        return products\n\n    def _abspath(self, doc, path: str) -&gt; str:\n        \"\"\"Return absolute path from possibly relative path.\"\"\"\n        if os.path.isabs(path):\n            return path\n\n        project_folder: str = doc.GetDocumentPath()\n        abs_path: str = os.path.normpath(os.path.join(project_folder, path))\n        self.log.debug(\n            f\"Resolved relative path '{path}' to absolute path '{abs_path}'\"\n        )\n        return abs_path\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_render.html#client.ayon_cinema4d.plugins.publish.collect_render.CollectCinema4DRender.get_expected_files","title":"<code>get_expected_files(render_instance)</code>","text":"<p>Return expected output files from the render</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_render.py</code> <pre><code>def get_expected_files(self, render_instance: Cinema4DRenderInstance):\n    \"\"\"Return expected output files from the render\"\"\"\n    # TODO: Support built-in standard, physical and viewport renderers\n    # TODO: Relative paths may need to be made absolute because otherwise\n    #  those paths will become relative to the PUBLISHED scenefile instead\n    #  of the WORKFILE?\n\n    instance: pyblish.api.Instance = render_instance.source_instance\n    render_data: c4d.documents.RenderData = render_instance.renderData\n    doc = render_data.GetDocument()\n\n    # From the Take and Render Data we find the correct output path,\n    # whether it is multipass and what AOVs are enabled for the renderer.\n    # Each output file is considered to be a \"Render Product\" similar to\n    # USD terminology.\n    take: c4d.modules.takesystem.BaseTake = (\n        instance.data[\"transientData\"][\"take\"]\n    )\n\n    # Debug log what take we're processing, etc.\n    self.log.debug(f\"Take: {take.GetName()}\")\n    self.log.debug(f\"  Render Settings: {render_data.GetName()}\")\n    self.log.debug(\n        \"  Frame range: \"\n        f\"{render_instance.frameStartHandle}-\"\n        f\"{render_instance.frameEndHandle}x\"\n        f\"{render_instance.frameStep}\"\n    )\n    self.log.debug(\n        f\"  Resolution:  \"\n        f\"{render_instance.resolutionWidth}x\"\n        f\"{render_instance.resolutionHeight}\"\n    )\n\n    # Debug log video posts\n    video_posts: list[c4d.documents.BaseVideoPost] = lib.get_siblings(\n        render_data.GetFirstVideoPost()\n    )\n    video_posts_names = \", \".join(vp.GetName() for vp in video_posts)\n    self.log.debug(f\"  Video posts: {video_posts_names}\")\n\n    name_format: int = render_data[c4d.RDATA_NAMEFORMAT]\n\n    def files_resolver(\n        token_path: str,\n        layer_name: str = \"$userpass\",\n        layer_type_name: str = \"$pass\",\n        file_format: int = render_data[c4d.RDATA_MULTIPASS_SAVEFORMAT],\n    ) -&gt; list[str]:\n        \"\"\"Return filepaths for all frames with given token path and\n        layer names.\"\"\"\n        files: list[str] = []\n        token_path = self._abspath(doc, token_path)\n        for frame in range(\n            render_instance.frameStartHandle,\n            render_instance.frameEndHandle + 1,\n        ):\n            resolved_path = lib_renderproducts.resolve_filepath(\n                token_path,\n                doc=doc,\n                render_data=render_data,\n                layer_name=layer_name,\n                layer_type_name=layer_type_name,\n                take=take,\n                frame=frame,\n            )\n            resolved_path = lib_renderproducts.apply_name_format(\n                resolved_path,\n                name_format=name_format,\n                file_format=file_format,\n                frame=frame\n            )\n            files.append(resolved_path)\n        return files\n\n    # Get take render data AOVs\n    products: dict[str, list[str]] = {}\n\n    # Regular image\n    save_image: bool = render_data[c4d.RDATA_SAVEIMAGE]\n    if save_image:\n        token_path: str = render_data[c4d.RDATA_PATH]\n        products[\"\"] = files_resolver(\n            token_path,\n            file_format=render_data[c4d.RDATA_FORMAT]\n        )\n\n    # Multi-Pass image\n    save_multipass_image: bool = render_data[c4d.RDATA_MULTIPASS_SAVEIMAGE]\n    if save_multipass_image:\n        products.update(\n            self._collect_multipass(\n                render_data,\n                files_resolver\n            )\n        )\n\n    # Set output dir from the beauty output because it is required for\n    # publish metadata to be written out and the publish job submission\n    # to succeed\n    if products:\n        first_product_file: str = next(iter(products.values()))[0]\n        render_instance.outputDir = os.path.dirname(first_product_file)\n        self.log.debug(\n            f\"Collected output directory: {render_instance.outputDir}\"\n        )\n    else:\n        render_instance.outputDir = None\n        self.log.warning(\"No render outputs collected; outputDir set to None.\")\n\n    # Debug log all collected sequences\n    for aov_name, aov_files in products.items():\n        if aov_name == \"\":\n            aov_name = \"&lt;Beauty&gt;\"\n\n        collections, remainder = clique.assemble(aov_files)\n        file_labels = remainder + list(\n            str(collection) for collection in collections\n        )\n        self.log.debug(f\"  {aov_name} files: {', '.join(file_labels)}\")\n\n    # Assume that for all render products we have the same colorspace\n    # so for now we will apply the scene render colorspace to all products\n    # This is used by the Submit Publish Job plug-in to set the colorspace\n    # for each instance\n    for aov_name, files in products.items():\n        render_instance.renderProducts.layer_data.products.append(\n            lib_renderproducts.RenderProduct(\n                productName=aov_name,\n                colorspace=render_instance.sceneRenderColorspace,\n            )\n        )\n\n    return [products]\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_workfile.html#client.ayon_cinema4d.plugins.publish.collect_workfile.CollectWorkfileData","title":"<code>CollectWorkfileData</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Inject data into Workfile instance</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfileData(pyblish.api.InstancePlugin):\n    \"\"\"Inject data into Workfile instance\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.01\n    label = \"Cinema4D Workfile\"\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Inject the current working file\"\"\"\n\n        context = instance.context\n        current_file = context.data[\"currentFile\"]\n        folder, file = os.path.split(current_file)\n        filename, ext = os.path.splitext(file)\n\n        data = {  # noqa\n            \"setMembers\": [current_file],\n            \"frameStart\": context.data['frameStart'],\n            \"frameEnd\": context.data['frameEnd'],\n            \"handleStart\": context.data['handleStart'],\n            \"handleEnd\": context.data['handleEnd']\n        }\n\n        data['representations'] = [{\n            'name': ext.lstrip(\".\"),\n            'ext': ext.lstrip(\".\"),\n            'files': file,\n            \"stagingDir\": folder,\n        }]\n\n        instance.data.update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/collect_workfile.html#client.ayon_cinema4d.plugins.publish.collect_workfile.CollectWorkfileData.process","title":"<code>process(instance)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_cinema4d/plugins/publish/collect_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Inject the current working file\"\"\"\n\n    context = instance.context\n    current_file = context.data[\"currentFile\"]\n    folder, file = os.path.split(current_file)\n    filename, ext = os.path.splitext(file)\n\n    data = {  # noqa\n        \"setMembers\": [current_file],\n        \"frameStart\": context.data['frameStart'],\n        \"frameEnd\": context.data['frameEnd'],\n        \"handleStart\": context.data['handleStart'],\n        \"handleEnd\": context.data['handleEnd']\n    }\n\n    data['representations'] = [{\n        'name': ext.lstrip(\".\"),\n        'ext': ext.lstrip(\".\"),\n        'files': file,\n        \"stagingDir\": folder,\n    }]\n\n    instance.data.update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/extract_alembic.html","title":"extract_alembic","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/extract_alembic.html#client.ayon_cinema4d.plugins.publish.extract_alembic.ExtractAlembic","title":"<code>ExtractAlembic</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract a Camera as Alembic.</p> <p>The cameras gets baked to world space by default. Only when the instance's <code>bakeToWorldSpace</code> is set to False it will include its full hierarchy.</p> Source code in <code>client/ayon_cinema4d/plugins/publish/extract_alembic.py</code> <pre><code>class ExtractAlembic(publish.Extractor):\n    \"\"\"Extract a Camera as Alembic.\n\n    The cameras gets baked to world space by default. Only when the instance's\n    `bakeToWorldSpace` is set to False it will include its full hierarchy.\n    \"\"\"\n\n    label = \"Alembic\"\n    hosts = [\"cinema4d\"]\n    families = [\"pointcache\"]\n\n    def process(self, instance):\n\n        doc: c4d.BaseDocument = instance.context.data[\"doc\"]\n\n        # Collect the start and end including handles\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n        step = instance.data.get(\"step\", 1)\n        bake_to_worldspace = instance.data(\"bakeToWorldSpace\", True)\n\n        nodes = instance[:]\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        filename = \"{0}.abc\".format(instance.name)\n        path = os.path.join(dir_path, filename)\n\n        export_nodes = self.filter_objects(nodes)\n\n        # Perform alembic extraction\n        with lib.maintained_selection():\n            lib.set_selection(doc, export_nodes)\n\n            # Export selection to camera\n            exporters.extract_alembic(\n                path,\n                frame_start=start,\n                frame_end=end,\n                frame_step=step,\n                selection=True,\n                global_matrix=bake_to_worldspace,\n                doc=doc,\n                # Log the applied options to the publish logs\n                verbose=True\n            )\n\n        representation = {\n            \"name\": \"abc\",\n            \"ext\": \"abc\",\n            \"files\": filename,\n            \"stagingDir\": dir_path,\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n\n        self.log.info(f\"Extracted instance '{instance.name}' to: {path}\")\n\n    def filter_objects(self, nodes):\n        return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/extract_redshiftproxy.html","title":"extract_redshiftproxy","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/extract_redshiftproxy.html#client.ayon_cinema4d.plugins.publish.extract_redshiftproxy.ExtractRedshiftProxy","title":"<code>ExtractRedshiftProxy</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract a Redshift Proxy</p> Source code in <code>client/ayon_cinema4d/plugins/publish/extract_redshiftproxy.py</code> <pre><code>class ExtractRedshiftProxy(publish.Extractor):\n    \"\"\"Extract a Redshift Proxy\"\"\"\n\n    label = \"Redshift Proxy\"\n    hosts = [\"cinema4d\"]\n    families = [\"redshiftproxy\"]\n\n    def process(self, instance):\n\n        doc: c4d.BaseDocument = instance.context.data[\"doc\"]\n\n        # Collect the start and end including handles\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n        step = instance.data.get(\"step\", 1)\n\n        export_nodes = instance[:]\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n\n        # Add the `_` suffix because Redshift Proxy export will add the\n        # frame numbers to the file names before the extension.\n        filename = \"{0}_.rs\".format(instance.name)\n        path = os.path.join(dir_path, filename)\n\n        # TODO: Set the document timeline to 'fit' the extra frame start and\n        #  frame end because redshift export fails if the frame range is\n        #  outside of the current document's timeline range.\n\n        # Perform alembic extraction\n        with lib.maintained_selection():\n            lib.set_selection(doc, export_nodes)\n\n            # Export selection to camera\n            exporters.extract_redshiftproxy(\n                path,\n                frame_start=start,\n                frame_end=end,\n                frame_step=step,\n                selection=True,\n                doc=doc,\n                # Log the applied options to the publish logs\n                verbose=True\n            )\n\n        # The Redshift exporter will add the frame numbers to the filepath\n        # before the extension. So we collect the resulting files.\n        frame_filepaths: \"list[str]\" = []\n        for frame in range(int(start), int(end) + 1):\n            head, tail = os.path.splitext(path)\n            frame_filepath = f\"{head}{frame:04d}{tail}\"\n            if not os.path.exists(frame_filepath):\n                raise publish.PublishError(\n                    \"Expected exported Redshift Proxy frame not found: \"\n                    f\"{frame_filepath}\")\n\n            frame_filepaths.append(frame_filepath)\n\n        # Define the collected filename with the frame numbers\n        frame_filenames = [os.path.basename(path) for path in frame_filepaths]\n        if len(frame_filepaths) == 1:\n            files = frame_filenames[0]\n        else:\n            files = frame_filenames\n\n        representation = {\n            \"name\": \"rs\",\n            \"ext\": \"rs\",\n            \"files\": files,\n            \"stagingDir\": dir_path,\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n\n        self.log.info(f\"Extracted instance '{instance.name}' to: {path}\")\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/extract_review.html","title":"extract_review","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/increment_current_file.html","title":"increment_current_file","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/increment_current_file.html#client.ayon_cinema4d.plugins.publish.increment_current_file.IncrementCurrentFile","title":"<code>IncrementCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Increment the current file.</p> <p>Saves the current scene with an increased version number.</p> Source code in <code>client/ayon_cinema4d/plugins/publish/increment_current_file.py</code> <pre><code>class IncrementCurrentFile(pyblish.api.ContextPlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"Increment the current file.\n\n    Saves the current scene with an increased version number.\n    \"\"\"\n    label = \"Increment current file\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    families = [\"*\"]\n    hosts = [\"cinema4d\"]\n    optional = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        # Filename must not have changed since collecting\n        host: IWorkfileHost = registered_host()\n        current_filepath: str = host.get_current_workfile()\n        if context.data[\"currentFile\"] != current_filepath:\n            raise KnownPublishError(\n                \"Collected filename mismatches from current scene name.\"\n            )\n\n        try:\n            from ayon_core.pipeline.workfile import save_next_version\n            from ayon_core.host.interfaces import SaveWorkfileOptionalData\n\n            current_filename = os.path.basename(current_filepath)\n            save_next_version(\n                description=(\n                    f\"Incremented by publishing from {current_filename}\"\n                ),\n                # Optimize the save by reducing needed queries for context\n                prepared_data=SaveWorkfileOptionalData(\n                    project_entity=context.data[\"projectEntity\"],\n                    project_settings=context.data[\"project_settings\"],\n                    anatomy=context.data[\"anatomy\"],\n                )\n            )\n            new_filepath = host.get_current_workfile()\n        except ImportError:\n            # Backwards compatibility before ayon-core 1.5.0\n            self.log.debug(\n                \"Using legacy `version_up`. Update AYON core addon to \"\n                \"use newer `save_next_version` function.\"\n            )\n            new_filepath = version_up(current_filepath)\n            host.save_workfile(new_filepath)\n\n        self.log.debug(f\"Incremented workfile to: {new_filepath}\")\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/save_scene.html#client.ayon_cinema4d.plugins.publish.save_scene.SaveCurrentScene","title":"<code>SaveCurrentScene</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save current scene</p> Source code in <code>client/ayon_cinema4d/plugins/publish/save_scene.py</code> <pre><code>class SaveCurrentScene(pyblish.api.ContextPlugin):\n    \"\"\"Save current scene\"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"cinema4d\"]\n\n    def process(self, context):\n\n        doc: c4d.documents.BaseDocument = context.data[\"doc\"]\n        # If file has no modifications, skip forcing a file save\n        if not doc.GetChanged():\n            self.log.debug(\"Skipping file save as there \"\n                           \"are no unsaved changes..\")\n            return\n\n        current_file = get_document_path(doc)\n        assert context.data['currentFile'] == current_file\n\n        self.log.debug(f\"Saving current file: {current_file}\")\n        c4d.documents.SaveDocument(\n            doc, current_file,\n            saveflags=c4d.SAVEDOCUMENTFLAGS_NONE,\n            format=c4d.FORMAT_C4DEXPORT\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/validate_frame_range.html","title":"validate_frame_range","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/validate_frame_range.html#client.ayon_cinema4d.plugins.publish.validate_frame_range.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the frame ranges.</p> <p>This is an optional validator checking if the frame range on instance matches the frame range specified for the asset.</p> <p>It also validates render frame ranges of render layers.</p> <p>Repair action will change everything to match the asset frame range.</p> <p>This can be turned off by the artist to allow custom ranges.</p> Source code in <code>client/ayon_cinema4d/plugins/publish/validate_frame_range.py</code> <pre><code>class ValidateFrameRange(\n    pyblish.api.InstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validates the frame ranges.\n\n    This is an optional validator checking if the frame range on instance\n    matches the frame range specified for the asset.\n\n    It also validates render frame ranges of render layers.\n\n    Repair action will change everything to match the asset frame range.\n\n    This can be turned off by the artist to allow custom ranges.\n    \"\"\"\n\n    label = \"Validate Frame Range\"\n    order = ValidateContentsOrder\n    families = [\"camera\", \"pointcache\", \"redshiftproxy\", \"render\", \"review\"]\n    optional = True\n    actions = [RepairAction]\n\n    settings_category = \"cinema4d\"\n\n    def process(self, instance: pyblish.api.Instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Get range from instance's context\n        entity = instance.data.get(\"taskEntity\", instance.data[\"folderEntity\"])\n        attrib: dict = entity[\"attrib\"]\n        frame_start: int = attrib[\"frameStart\"]\n        frame_end: int = attrib[\"frameEnd\"]\n        handle_start: int = attrib[\"handleStart\"]\n        handle_end: int = attrib[\"handleEnd\"]\n\n        # Get instance frame range\n        inst_frame_start = int(instance.data.get(\"frameStart\"))\n        inst_frame_end = int(instance.data.get(\"frameEnd\"))\n        inst_handle_start = int(instance.data.get(\"handleStart\"))\n        inst_handle_end = int(instance.data.get(\"handleEnd\"))\n\n        # compare with data on instance\n        invalid = False\n        checks = {\n            \"Frame start\": (frame_start, inst_frame_start),\n            \"Frame end\": (frame_end, inst_frame_end),\n            \"Handle start\": (handle_start, inst_handle_start),\n            \"Handle end\": (handle_end, inst_handle_end),\n        }\n        for label, values in checks.items():\n            context_value, instance_value = values\n            if context_value != instance_value:\n                self.log.warning(\n                    \"{} on instance ({}) does not match with the folder \"\n                    \"({}).\".format(label, instance_value, context_value)\n                )\n                invalid = True\n\n        if invalid:\n            raise PublishValidationError(\n                \"Instance frame range is incorrect.\",\n                title=\"Frame Range incorrect\",\n            )\n\n    @classmethod\n    def repair(cls, instance: pyblish.api.Instance):\n        from ayon_cinema4d.api.commands import reset_frame_range\n\n        reset_frame_range()\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/validate_render_relative_paths.html","title":"validate_render_relative_paths","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/validate_render_relative_paths.html#client.ayon_cinema4d.plugins.publish.validate_render_relative_paths.ValidateRenderRelativePaths","title":"<code>ValidateRenderRelativePaths</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates render scene does not use relative paths.</p> <p>Because the scene will be rendered from the published folder if it renders to a relative path then the output will end up in the publish folder instead of the expected location.</p> Source code in <code>client/ayon_cinema4d/plugins/publish/validate_render_relative_paths.py</code> <pre><code>class ValidateRenderRelativePaths(\n    pyblish.api.InstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validates render scene does not use relative paths.\n\n    Because the scene will be rendered from the published folder if it renders\n    to a relative path then the output will end up in the publish folder\n    instead of the expected location.\n\n    \"\"\"\n\n    label = \"Validate Render Relative Paths\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"render\"]\n    optional = False\n    actions = [RepairAction]\n\n    settings_category = \"cinema4d\"\n\n    def process(self, instance: pyblish.api.Instance):\n        if not self.is_active(instance.data):\n            return\n\n        doc: c4d.documents.BaseDocument = instance.context.data[\"doc\"]\n        take_data = doc.GetTakeData()\n        take: c4d.modules.takesystem.BaseTake = instance.data[\"transientData\"][\n            \"take\"\n        ]\n        render_data, base_take = take.GetEffectiveRenderData(take_data)\n        invalid: bool = False\n\n        # Regular image\n        save_image: bool = render_data[c4d.RDATA_SAVEIMAGE]\n        if save_image:\n            token_path: str = render_data[c4d.RDATA_PATH]\n            if not os.path.isabs(token_path):\n                self.log.error(\n                    \"Regular image Render output path is relative:\\n\"\n                    f\"{token_path}\"\n                )\n                invalid = True\n\n        # Multi-Pass image\n        save_multipass_image: bool = render_data[c4d.RDATA_MULTIPASS_SAVEIMAGE]\n        if save_multipass_image:\n            token_path: str = render_data[c4d.RDATA_MULTIPASS_FILENAME]\n            if not os.path.isabs(token_path):\n                self.log.error(\n                    \"Multi-Pass Image render output path is relative:\\n\"\n                    f\"{token_path}\",\n                )\n                invalid = True\n\n        if invalid:\n            raise PublishValidationError(\n                \"Please use an absolute path for render output.\",\n                description=self.get_description(),\n            )\n\n    @classmethod\n    def repair(cls, instance: pyblish.api.Instance):\n        current_file = instance.context.data[\"currentFile\"]\n        if not current_file:\n            raise RuntimeError(\n                \"Cannot repair relative paths because the current \"\n                \"file path is unknown. Please save the Cinema 4D \"\n                \"project and try again.\"\n            )\n        current_folder = os.path.dirname(current_file)\n\n        doc: c4d.documents.BaseDocument = instance.context.data[\"doc\"]\n        take_data = doc.GetTakeData()\n        take: c4d.modules.takesystem.BaseTake = instance.data[\"transientData\"][\n            \"take\"\n        ]\n        render_data, base_take = take.GetEffectiveRenderData(take_data)\n\n        for key, label in RENDER_DATA_KEYS.items():\n            token_path: str = render_data[key]\n\n            # Strip leading dot from ./ or .\\ start if present\n            if token_path.startswith((\"./\", \".\\\\\")):\n                token_path = token_path[2:]\n\n            if not os.path.isabs(token_path):\n                render_data[key] = os.path.join(current_folder, token_path)\n\n        c4d.EventAdd()\n\n    @classmethod\n    def get_description(cls) -&gt; str:\n        return inspect.cleandoc(\n            \"\"\"### Render paths are relative\n\n            The render output paths must be absolute paths.\n\n            Relative paths can lead to renders being saved in unexpected\n            locations due to the render possibly occurring from a published\n            workfile.\n\n            Use the 'Repair' action to convert relative paths to\n            absolute paths based on the current Cinema4D project folder.\n        \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/validate_resolution.html","title":"validate_resolution","text":""},{"location":"autoapi/client/ayon_cinema4d/plugins/publish/validate_resolution.html#client.ayon_cinema4d.plugins.publish.validate_resolution.ValidateResolution","title":"<code>ValidateResolution</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the render resolution setting aligned with DB</p> Source code in <code>client/ayon_cinema4d/plugins/publish/validate_resolution.py</code> <pre><code>class ValidateResolution(\n    pyblish.api.InstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validate the render resolution setting aligned with DB\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"render\"]\n    label = \"Validate Resolution\"\n    actions = [RepairAction]\n    optional = True\n\n    settings_category = \"cinema4d\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid_resolution(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Render resolution is invalid. See log for details.\",\n                description=(\n                    \"Wrong render resolution setting. \"\n                    \"Please use repair button to fix it.\\n\\n\"\n                ),\n            )\n\n    @classmethod\n    def get_invalid_resolution(cls, instance):\n        # Current resolution for take\n        doc = instance.context.data[\"doc\"]\n        take_data = doc.GetTakeData()\n        take: c4d.modules.takesystem.BaseTake = (\n            instance.data[\"transientData\"][\"take\"]\n        )\n        rd, _base_take = take.GetEffectiveRenderData(take_data)\n        current_width: int = rd[c4d.RDATA_XRES]\n        current_height: int = rd[c4d.RDATA_YRES]\n        current_pixel_aspect: float = rd[c4d.RDATA_PIXELASPECT]\n\n        # Expected resolution\n        width, height, pixel_aspect = cls.get_context_resolution(instance)\n\n        invalid = False\n        if current_width != width or current_height != height:\n            cls.log.error(\n                \"Render resolution {}x{} does not match \"\n                \"context resolution {}x{}\".format(\n                    current_width, current_height, width, height\n                )\n            )\n            invalid = True\n        if current_pixel_aspect != pixel_aspect:\n            cls.log.error(\n                \"Render pixel aspect {} does not match \"\n                \"context pixel aspect {}\".format(\n                    current_pixel_aspect, pixel_aspect\n                )\n            )\n            invalid = True\n        return invalid\n\n    @classmethod\n    def get_context_resolution(\n        cls, instance: pyblish.api.Instance\n    ) -&gt; tuple[int, int, float]:\n        task_attributes = instance.data[\"taskEntity\"][\"attrib\"]\n        width = task_attributes[\"resolutionWidth\"]\n        height = task_attributes[\"resolutionHeight\"]\n        pixel_aspect = task_attributes[\"pixelAspect\"]\n        return int(width), int(height), float(pixel_aspect)\n\n    @classmethod\n    def repair(cls, instance: pyblish.api.Instance):\n        if not cls.get_invalid_resolution(instance):\n            cls.log.debug(\"Nothing to repair on instance: {}\".format(instance))\n            return\n\n        # Note that this always repairs the resolution to the current\n        # context and does not reset it to the context of the target instance\n        # TODO: Support setting resolution from other context\n        reset_resolution()\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/imageio.html#server.imageio.WorkfileImageIOModel","title":"<code>WorkfileImageIOModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Workfile settings help.</p> <p>Empty values will be skipped, allowing any existing env vars to pass through as defined.</p> Source code in <code>server/imageio.py</code> <pre><code>class WorkfileImageIOModel(BaseSettingsModel):\n    \"\"\"Workfile settings help.\n\n    Empty values will be skipped, allowing any existing env vars to\n    pass through as defined.\n    \"\"\"\n    enabled: bool = SettingsField(False, title=\"Enabled\")\n    render: str = SettingsField(\n        default=\"ACES\",\n        title=\"Default render space\",\n        description=\"It behaves like the 'OCIO_RENDER_SPACE' env var,\"\n                    \" The role of the working space, e.g scene_linear\"\n    )\n    display: str = SettingsField(\n        default=\"ACES\",\n        title=\"Default active displays\",\n        description=\"It behaves like the 'OCIO_ACTIVE_DISPLAYS' env var,\"\n                    \" Colon-separated list of displays, e.g ACES:P3\"\n    )\n    view: str = SettingsField(\n        default=\"sRGB\",\n        title=\"Default active views\",\n        description=\"It behaves like the 'OCIO_ACTIVE_VIEWS' env var,\"\n                    \" Colon-separated list of views, e.g sRGB:DCDM\"\n    )\n    thumbnails: str = SettingsField(\n        default=\"sRGB\",\n        title=\"Thumbnails\",\n    )\n</code></pre>"},{"location":"autoapi/server/publish.html","title":"publish","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""}]}